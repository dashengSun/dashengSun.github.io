<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>DevOps on Whisperd</title><link>https://kaichaosun.github.io/categories/devops/</link><description>Recent content in DevOps on Whisperd</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 30 Mar 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://kaichaosun.github.io/categories/devops/index.xml" rel="self" type="application/rss+xml"/><item><title>Cheatsheet for Shell Programming</title><link>https://kaichaosun.github.io/post/shell-cheatsheet/</link><pubDate>Sat, 30 Mar 2019 00:00:00 +0000</pubDate><guid>https://kaichaosun.github.io/post/shell-cheatsheet/</guid><description>Variables NAME=&amp;#34;John&amp;#34; echo $NAME echo &amp;#34;$NAME&amp;#34; echo &amp;#34;${NAME}!&amp;#34; String NAME=&amp;#34;John&amp;#34; echo &amp;#34;Hi $NAME&amp;#34; #=&amp;gt; Hi John echo &amp;#39;Hi $NAME&amp;#39; #=&amp;gt; Hi $NAME Array Fruits=(&amp;#39;Apple&amp;#39; &amp;#39;Banana&amp;#39; &amp;#39;Orange&amp;#39;) Fruits[0]=&amp;#34;Apple&amp;#34; Fruits[1]=&amp;#34;Banana&amp;#34; Fruits[2]=&amp;#34;Orange&amp;#34; And / Or git commit &amp;amp;&amp;amp; git push git commit || echo &amp;#34;Commit failed&amp;#34; Function get_name() { echo &amp;#34;John&amp;#34; } echo &amp;#34;You are $(get_name)&amp;#34; myfunc() { echo &amp;#34;hello $1&amp;#34; } # Same as above (alternate syntax) function myfunc() { echo &amp;#34;hello $1&amp;#34; } myfunc &amp;#34;John&amp;#34; If else if [[ -z ${APP_ENV} ]]; then echo &amp;#34;The APP_ENV should be set to prod or staging, got: $0&amp;#34; exit -1 fi if [[ -z &amp;#34;$string&amp;#34; ]]; then echo &amp;#34;String is empty&amp;#34; elif [[ -n &amp;#34;$string&amp;#34; ]]; then echo &amp;#34;String is not empty&amp;#34; fi Condition [[ -z STRING ]] # Empty string [[ -n STRING ]] # Not empty string [[ STRING == STRING ]] # Equal [[ STRING !</description></item><item><title>The Tutorial of Manjaro Linux Usage</title><link>https://kaichaosun.github.io/post/master_linux_os/</link><pubDate>Sun, 03 Mar 2019 00:00:00 +0000</pubDate><guid>https://kaichaosun.github.io/post/master_linux_os/</guid><description>[TOC]
Install Manjaro Linux Burn image to usb stick: Steps:
Download mankato - GNOME here
Check the hash and compare with the hash provided on the site:
shasum ./manjaro-gnome-18.0.2-stable-x86_64.iso Burn the iso file to USB stick on Linux diskutil list sudo umount /dev/disk2s4 sudo dd if=/path/image.iso of=/dev/rdisk2s4 bs=1m On windows, use rufus with dd mode.
Bios set Insert USB stick Restart pc with F2 into bios，set secure boot to be disable，F10 save and exit Press F12 select start using USB.</description></item><item><title>Cheatsheet for Common Usage CLI</title><link>https://kaichaosun.github.io/post/common-cli-cheatsheet/</link><pubDate>Wed, 02 Jan 2019 00:00:00 +0000</pubDate><guid>https://kaichaosun.github.io/post/common-cli-cheatsheet/</guid><description>Curl Post JSON curl -i -d &amp;#39;{&amp;#34;id&amp;#34;: &amp;#34;111111&amp;#34;,&amp;#34;date&amp;#34;: &amp;#34;2018-04-27T00:00:00+10:00&amp;#34;,&amp;#34;des&amp;#34;: &amp;#34;test&amp;#34;}]&amp;#39; -H &amp;#34;Content-Type: application/json&amp;#34; -X POST https://endpoint curl -i -d &amp;#39;{&amp;#34;a&amp;#34;:&amp;#34;1&amp;#34;,&amp;#34;b&amp;#34;:&amp;#34;2&amp;#34;}&amp;#39; -H &amp;#34;Content-Type: application/json&amp;#34; -X POST https://endpoint Database MySQL SHOW VARIABLES; SELECT FROM_UNIXTIME(1510289234); SELECT NOW(); SELECT UNIX_TIMESTAMP(); MongoDB mongod --dbpath ~/data/mongodb Zip / tar zip filename.zip file1 file2 tar -czvf name-of-archive.tar.gz /path/to/directory-or-file -c: Create an archive. -z: Compress the archive with gzip. -v: Display progress in the terminal while creating the archive, also known as “verbose” mode.</description></item><item><title>Kubernetes basics</title><link>https://kaichaosun.github.io/post/kubernetes-basics/</link><pubDate>Thu, 21 Jun 2018 00:00:00 +0000</pubDate><guid>https://kaichaosun.github.io/post/kubernetes-basics/</guid><description>Background &amp;amp; why kubernetes Micro services Usually we build a single &amp;ldquo;monolith&amp;rdquo; application at first time. As the business grows, the app becomes &amp;ldquo;heavy&amp;rdquo; and hard to maintain:
Improved cost to communicate within different teams; Long enough time to finish the CI pipeline(run the test cases, packages, deployment); Hard to scale; &amp;hellip; So we need to make big application to be small different services depends on a few principles, that's micro services.</description></item><item><title>理解Golang并发编程</title><link>https://kaichaosun.github.io/post/go-channel/</link><pubDate>Sat, 29 Jul 2017 00:00:00 +0000</pubDate><guid>https://kaichaosun.github.io/post/go-channel/</guid><description>concurrency vs parallelism 并发和并行是彼此相关的两个概念，并不能完全等价。
在程序中，并发强调的是独立执行的程序的组合；并行强调的是同时执行计算任务[1]。
计算机核心的数量决定了并行计算的能力，大多数人类作为“单核”动物(老顽童小龙女除外)，可以说自己在并发某些任务，如我在听歌写代码，但是不能说这两件事在并行，参考下图：
![concurrency vs parallelism](/static/go-channel/currency vs parallelism.png)
Golang的并发模型源于Communicating Sequential Processes (CSP)，通过提供goroutine和channel来实现并发编程模式。
Goroutine Goroutine由Go运行时创建和管理，是用于调度CPU资源的“最小单元”，和OS的线程相比更轻量[2]:
内存消耗更低只需2kB初始栈空间，而线程初始要1Mb的空间； 由golang的运行时环境创建和销毁，更加廉价，不支持手动管理； 切换效率更高等。 Goroutine和线程的关系如下图所示： ![goroutine vs thread](/static/go-channel/goroutine vs thread.png)
我们可以轻松地创建成百上千的goroutine，而不会降低程序的执行效率。
通过goroutine可以让一个函数和其他的函数并行执行。可以在函数调用前面加上go关键字，方便地创建一个goroutine。
main函数本身也是一个goroutine[3]。
举例如下：
package main import &amp;quot;fmt&amp;quot; func main() { fmt.Println(&amp;quot;begin main goroutine&amp;quot;) go hello() fmt.Println(&amp;quot;end main goroutine&amp;quot;) } func hello() { fmt.Println(&amp;quot;begin hello goroutine&amp;quot;) } 输出：
begin main goroutine end main goroutine 上面的例子中，并不会输出begin hello goroutine，这是因为， 通过使用goroutine，我们不需要等待函数调用的返回结果，而会接着执行下面的代码。
可以在go hello()后面添加：
time.Sleep(1 * time.</description></item><item><title>Golang web 开发</title><link>https://kaichaosun.github.io/post/golang-docker-ci/</link><pubDate>Wed, 05 Jul 2017 00:00:00 +0000</pubDate><guid>https://kaichaosun.github.io/post/golang-docker-ci/</guid><description>背景 Web应用长期以来是Ruby、Java、PHP等开发语言的战场。
Ruby可以实现快速原型开发，Ruby On Rails “全能”框架实现“全栈”开发，缺点有大型应用性能差、调试困难； Java 20多年的发展历程，各种第三方库、框架健全，运行效率高， 但是随着应用的功能膨胀，臃肿的get/set方法，JVM占用大量计算机资源、性能调试困难，函数式编程不友好。 PHP，TL;DR 本文实现了一个最小化web应用，以此来了解Golang web的生态，通过使用Docker隔离开发环境， 使用Posgres持久化数据，源代码请参考这里
Why Go? 性能优越 部署简单，只需要将打包好的二进制文件部署到服务器上 内置丰富的标准库，让程序员的生活变得简单美好 静态语言，类型检查 duck typing goroutine将开发人员从并发编程中解放出来 函数作为“一等公民” &amp;hellip; Golang第三方框架选择 Web框架: Gin，性能卓越，API友好，功能完善 ORM: GORM,支持多种主流数据库方言，文档清晰 包管理工具: Glide,类似于Ruby的bundler或者NodeJS中的npm 测试工具: GoConvey,符合BDD测试风格,支持浏览器测试结果的可视化 Testify,提供丰富的断言和Mock功能 数据库migration: migrate 日志工具: Logrus,结构化日志输出，完全兼容标准库的logger Dockerize 开发环境 发布应用 base image Dockerfile如下:
FROM golang:1.8 # 包管理工具 RUN curl https://glide.sh/get | sh # 代码热加载 RUN go get github.</description></item><item><title>理解 Javascript 的几种异步模式</title><link>https://kaichaosun.github.io/post/callback-promise/</link><pubDate>Wed, 05 Apr 2017 00:00:00 +0000</pubDate><guid>https://kaichaosun.github.io/post/callback-promise/</guid><description>Javacript 提供了基于回调的异步编程模式，如回调函数，Promise对象，Async Function 等。下面是我在学习过程中总结的 一些特性和使用方式。
Javascript 运行时概念 栈(Stack) 和其他语言一样, 栈保存了函数调用的层次关系, 栈中的每一块叫做一帧(frame), 最上层的那一帧, 代表了最内层的函数, 当函数返回时, 清空帧, 当调用栈中所有的帧清空(即最外层函数返回), 当前执行的代码块结束。 JS调用栈有三个特点:
单线程, 浏览器的JS引擎本身是多线程的, 但是JS的调用栈是单线程的, 一次只能执行一段代码; 同步执行, 在栈中的任务依次执行并返回, 不能在任务之间切换 非阻塞, 在线程繁忙时, 浏览器仍然可以接收事件 堆(Heap) 堆中保存了大量的对象,垃圾收集器定期清理未被引用的对象。
事件队列(event queue) 当调用某些Web APIs时,如DOM事件(如鼠标点击操作)、XMLHttpRequest, setTimeout()等, 会添加callback函数到event queue。
Event loop Event loop将event queue中按照&amp;quot;FIFO&amp;quot;的顺序将callback取出,放入栈中,callback函数返回,清空栈, 循环执行上述步骤。
MDN提供的伪代码实现如下:
while(queue.waitForMessage()) { queue.processNextMessage(); } Callback Callback函数 和其他编程语言(Java, Ruby)不同,在JS中,函数也是对象(Function instanceof Object返回为true)。 函数是JS的&amp;quot;一等公民&amp;rdquo;,通俗的理解是,可以将函数作为参数传给另外一个函数,也可以将一个函数作为另一个函数的返回值。
function bar(cb) { setTimeout(cb,2000); } function foo() { console.</description></item><item><title>使用 Hexo 搭建个人博客</title><link>https://kaichaosun.github.io/post/hexo/</link><pubDate>Wed, 04 Jan 2017 00:00:00 +0000</pubDate><guid>https://kaichaosun.github.io/post/hexo/</guid><description>Note: 已经使用Hugo创建博客。
Hexo 是一个博客框架,支持Markdown,通过命令行可以快速部署, 有大量的主题和插件,让你的blog飞起来&amp;hellip;
安装 Hexo sudo npm install -g hexo-cli hexo -v 创建 Github blog project 个人习惯将source和deploy分开,在github上创建一个blog项目(保存源文件)和 xxx.github.io项目(用于部署Github个人主页,xxx为用户名,具体参考Github Pages)
hexo init blog cd blog npm install Run server $ hexo s More info: Server
设置博客页个人信息 我的配置文件 _config.yml
# Site title: Whisperd subtitle: description: make a difference author: kaichao language: timezone: Asia/Shanghai # URL ## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/' url: https://kaichaosun.</description></item></channel></rss>