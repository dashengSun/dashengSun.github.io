<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Whisperd</title>
    <link>https://whisperd.tech/</link>
    <description>Recent content on Whisperd</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 30 Mar 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://whisperd.tech/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Cheatsheet for Shell Programming</title>
      <link>https://whisperd.tech/post/shell-cheatsheet/</link>
      <pubDate>Sat, 30 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://whisperd.tech/post/shell-cheatsheet/</guid>
      <description>Variables NAME=&amp;quot;John&amp;quot; echo $NAME echo &amp;quot;$NAME&amp;quot; echo &amp;quot;${NAME}!&amp;quot;  String NAME=&amp;quot;John&amp;quot; echo &amp;quot;Hi $NAME&amp;quot; #=&amp;gt; Hi John echo &#39;Hi $NAME&#39; #=&amp;gt; Hi $NAME  Array Fruits=(&#39;Apple&#39; &#39;Banana&#39; &#39;Orange&#39;) Fruits[0]=&amp;quot;Apple&amp;quot; Fruits[1]=&amp;quot;Banana&amp;quot; Fruits[2]=&amp;quot;Orange&amp;quot;  And / Or git commit &amp;amp;&amp;amp; git push git commit || echo &amp;quot;Commit failed&amp;quot;  Function get_name() { echo &amp;quot;John&amp;quot; } echo &amp;quot;You are $(get_name)&amp;quot; myfunc() { echo &amp;quot;hello $1&amp;quot; } # Same as above (alternate syntax) function myfunc() { echo &amp;quot;hello $1&amp;quot; } myfunc &amp;quot;John&amp;quot;  If else if [[ -z ${APP_ENV} ]]; then echo &amp;quot;The APP_ENV should be set to prod or staging, got: $0&amp;quot; exit -1 fi if [[ -z &amp;quot;$string&amp;quot; ]]; then echo &amp;quot;String is empty&amp;quot; elif [[ -n &amp;quot;$string&amp;quot; ]]; then echo &amp;quot;String is not empty&amp;quot; fi  Condition [[ -z STRING ]]	# Empty string [[ -n STRING ]]	# Not empty string [[ STRING == STRING ]]	# Equal [[ STRING !</description>
    </item>
    
    <item>
      <title>The Tutorial of Manjaro Linux Usage</title>
      <link>https://whisperd.tech/post/master_linux_os/</link>
      <pubDate>Sun, 03 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://whisperd.tech/post/master_linux_os/</guid>
      <description>[TOC]
Install Manjaro Linux Burn image to usb stick: Steps:
 Download mankato - GNOME here
 Check the hash and compare with the hash provided on the site:
  shasum ./manjaro-gnome-18.0.2-stable-x86_64.iso   Burn the iso file to USB stick on Linux  diskutil list sudo umount /dev/disk2s4 sudo dd if=/path/image.iso of=/dev/rdisk2s4 bs=1m  On windows, use rufus with dd mode.
Bios set  Insert USB stick Restart pc with F2 into bios，set secure boot to be disable，F10 save and exit Press F12 select start using USB.</description>
    </item>
    
    <item>
      <title>老宅记忆</title>
      <link>https://whisperd.tech/post/laozhai-jiyi/</link>
      <pubDate>Wed, 06 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://whisperd.tech/post/laozhai-jiyi/</guid>
      <description>时间大概是我遇到过最抽象的概念。
到现在，依然没有搞明白时间于我或者我们的意义。通过观察老宅，希望能明白一些。
说故事，还是得从自己说起，因为感受深刻，记忆详实。时间不必清晰，人物也谈不上典型，故事更是最寻常不过的。
老宅是一块记忆的活化石，记忆是我。
大年三十，是家里最热闹的日子，因为是爷爷的生日，外面混的不论好坏，人得到齐。
中午的伙食，来于长辈的辛劳。
吃席从来是足够复杂的一件事情，成年汉子必须喝酒，不会喝，就得练，酒桌文化我想，也算是中国普及最广的文化了，超越了地区贫富高低。一杯酒，喜乐恩仇。极少数的情况下，我会觉得喝酒有乐趣，大概是没有酒量。但是又须和其他人保持步调一致，这是很易理解的，围绕一张桌的是快三十年的相互了解，一致比不一致要容易太多了。
吃完饭，要去上坟祭祖，拿上鞭炮，汤水，就要出发。一路上，废弃的玉米杆铺路，尘土轻扬，心情松畅。到了跟父辈兄弟沟通最深刻话题的时段了，生与湮灭，落叶归根，大题面前，总能窥见人格的变迁。我从来没见过爷爷的爹，也就是老爷爷，因为没见过，才觉得神秘，才有很多的故事流传于耳畔。记忆碎片里有小时候老奶奶在的日子，阳光、板凳和微笑。
一年的结束和开始，在我的内心，永远是初一这两天。大清早就鞭炮雷动，驱年守岁。拜年，最传统的项目，在记忆里占据了大篇幅。小时候喜欢拜年，因为这是一年中唯一光明正大的挣钱机会。亲戚邻里，奶奶叔叔，进门先高喊，喊的声音大，年气儿才够浓，给压岁钱才会痛快。正经说，拜年不是一件光嘴上寒暄的容易事儿，进堂屋，迎正墙，磕头跪地，单腿双膝，诚意可见。磕了头，一定是敬烟吃糖，一顿寒暄，来去几个回合，内容一共没几句，但是一句不该多，更一句不能少。升了学的，到了年龄还没结婚的，刚结了婚有小孩儿的，一定被抓着手多问几句，这个时候一定不能表现出厌烦，过了年，出门在外，漫无目的的关心仿佛也变成了奢侈品。
年节，过的是一个心气儿，拍着记忆中的老宅，给这个年增加了一点新意。
不经意，看到时间流去。谈笑里，新庙老宅骤雨。</description>
    </item>
    
    <item>
      <title>(WIP) Dependency Injection in Scala</title>
      <link>https://whisperd.tech/post/dependency_injection_in_scala/</link>
      <pubDate>Thu, 17 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://whisperd.tech/post/dependency_injection_in_scala/</guid>
      <description>What&amp;rsquo;s Dependency Injection Dependency Injection is also known as DI for short. It is all about the way to integrate code between provider and consumer.
Usually, the provider provides functionalities that encapsulated in a function or an object. The consumer, in the opposite it needs to have a provider to do some work.
Then we say that the consumer dependent on the specific provider. There are two options that we can get this provider:</description>
    </item>
    
    <item>
      <title>Understand Error Handling in Scala</title>
      <link>https://whisperd.tech/post/error_handling_in_scala/</link>
      <pubDate>Thu, 17 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://whisperd.tech/post/error_handling_in_scala/</guid>
      <description>What&amp;rsquo;s Exception Exception are objects that defined in Java to represent error scenarios. Unhandled exceptions could terminate the program or show default message from http server.
Excpetion hirarchy Since Scala is designed to reuse Java standard or thirdparth library without much effort. It still worth to know the exception hirarachy originated in Java. It will help us deal with error scenarios.
 Throwable is the root of exception hirarchy. Exception subclasses represent errors that the program can recover from.</description>
    </item>
    
    <item>
      <title>Cheatsheet for Common Usage CLI</title>
      <link>https://whisperd.tech/post/common-cli-cheatsheet/</link>
      <pubDate>Wed, 02 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://whisperd.tech/post/common-cli-cheatsheet/</guid>
      <description>Curl Post JSON curl -i -d &#39;{&amp;quot;id&amp;quot;: &amp;quot;111111&amp;quot;,&amp;quot;date&amp;quot;: &amp;quot;2018-04-27T00:00:00+10:00&amp;quot;,&amp;quot;des&amp;quot;: &amp;quot;test&amp;quot;}]&#39; -H &amp;quot;Content-Type: application/json&amp;quot; -X POST https://endpoint curl -i -d &#39;{&amp;quot;a&amp;quot;:&amp;quot;1&amp;quot;,&amp;quot;b&amp;quot;:&amp;quot;2&amp;quot;}&#39; -H &amp;quot;Content-Type: application/json&amp;quot; -X POST https://endpoint  Database MySQL SHOW VARIABLES; SELECT FROM_UNIXTIME(1510289234); SELECT NOW(); SELECT UNIX_TIMESTAMP();  MongoDB mongod --dbpath ~/data/mongodb  Zip / tar zip filename.zip file1 file2  SSH / scp // setup tunel ssh -L 8002:target-host-ip:80 -i ~/.ssh/ssh-key hostname@host-ip // from local to remote scp /filename hostname@ip:~ // from remote to local scp -i ~/.</description>
    </item>
    
    <item>
      <title>Understand Monad in Functional Programming</title>
      <link>https://whisperd.tech/post/understand-monad/</link>
      <pubDate>Sat, 13 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://whisperd.tech/post/understand-monad/</guid>
      <description>Why Functional Programming? The facination of doing programming is to solve the exist problems. Revisit the history of software development, at first place we have procedure-oriented programming. As the system becomes bigger, the codebase is so hard to maintain and adding new features. Then a few genius comes out the idea with OOP with the SOLID principles to guide the daily dev work.
If there is one rule in software development, i think that must be no silver bullet.</description>
    </item>
    
    <item>
      <title>理解Ethereum智能合约开发</title>
      <link>https://whisperd.tech/post/solidity-basics/</link>
      <pubDate>Fri, 22 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://whisperd.tech/post/solidity-basics/</guid>
      <description>[TOC]
背景知识 为什么是分布式账本？ 从第一台计算机的诞生开始，地球的计算能力就一直在按照摩尔定律 (每隔两年计算能力翻倍)所指示的那样，持续地在增长（近年有放缓）。计算早已经不再是一种稀缺的资源，个人计算机的普及乃至泛滥，也说明了这一现象。
另一方面，我们处在飞速发展的信息社会，各种媒介充斥在生活里的方方面面，每个人在互联网上留下的一切痕迹，统称为数据，也是信息社会最有价值的。如果你看过《西部世界》，你就能够明白数据的力量是有多强大和危险。越来越多的人，意识到这一点，并且不希望自己的数据尤其是私密数据被企业或组织控制。
这些企业包含但不局限于支付宝、微信等等独角兽企业。分布式账本技术去除了对中心化的服务或组织的依赖，通过提供计算资源，每一个计算单元或者节点（简单的说就是一台计算机）共同维护着一个数据库或者账本，数据库中的数据可以被所有人读，但只有数据的拥有人才能进行转移或者处理，甚至可以进一步通过密码学对数据加密存储，只有持有秘钥的数据拥有人才能读取和处理数据。
数据的价值在于流动。不论在什么系统中，交易都是极为重要的，但是交易必须是可控和合理的。任何交易的促成都需要建立在一定的共识基础上。比如中心化的服务支付宝，交易成功的标识是支付宝后台数据库完成价值的转移，并返回成功消息给用户，支付宝是整个交易周期的信任基础。种种原因导致我们并不是百分百地信任支付宝。而去中心化的系统不存在这样的信任中心角色，交易的最终确定是由整个系统基于一定的共识算法完成的，这些算法包括但不局限于工作量证明、权益证明、代理权益证明等。
在分布式账本技术中，我们通过移除信任中心，实现了数据自由；通过开源代码，建立了另一个维度的信任关系。这项技术，还处在很早期的阶段，需要通过减缓交易的完成时间来提高安全性；需要通过花费大量的计算资源来达到彻底的去中心化。
到底什么是智能合约？ 日常生活中充满了各种各样的合约机制，比如房屋租赁合约、银行存取款合约、商务合作合约等等，这些合约的目的都只有一个，就是保证合约的参与方正常履行自己的义务。
智能合约的作用也是同样的，只不过合约的形式发生了改变，不再是纸质签名，而是存储在分布式账本中的代码。
为什么要选择智能合约而不是传统合约形式呢？原因我总结大致有以下几个：
 去中心化的合约形式，摆脱了对代理人的依赖，解决了对于代理人的信任问题。 分布式账本这个跨越一切国家和地区的技术，使得自由的全球化经济更进一步发展，智能合约能够方便快速地满足多种行业全球化经济的需要。 智能合约以开源代码的形式展示，使得合约更加可信、透明。 新的组织、文化、工作形式，如远程协作办公，开源社团，需要一个更加灵活地协作方式，这里应用智能合约恰到好处。 正是由于代码运行在公共的分布式账本上，满足条件的合约可以随时执行，永不离线。  合约解决了现实生活中的协作问题，智能合约则将协作的广度和深度推向了另一个高度。
以太坊和Solidity 以太坊 分布式账本和智能合约的结合，创造了一种新的协作方式。以太坊作为一个公共的分布式账本，提供了一个可复制的虚拟机环境，用来执行智能合约代码，保证了每个节点执行相同的代码和交易请求会得到相同的结果。
当应用程序的功能由智能合约来提供时，也常被认为是去中心化应用 (DAPP)。DApp前端依然是传统的HTML、CSS、JavaScript “三剑客”，通过发送请求到以太坊节点，上传数据到链上，响应链上的事件如智能合约代码的执行结果。对于DApp的后端，从传统中心化的服务器转变为链上可执行的智能合约，通过执行链上的交易请求完成用户账户或者合约账户状态的改变。
越来越多的领域采用DApp的解决方案，例如：
 知识产权保护 金融衍生品交易 去中心化的自治组织  Solidity编程语言 所有上面那些复杂的应用场景，都是用Solidity编写的智能合约来完成的。和大多数高级编程语言类似，Solidity支持面向对象的编程范式，有完善的类型系统，是一种静态编程语言，语法和Javascript很类似。你可以通过交互式编程环境熟悉Solidity的基本用法
基础数据类型 基于按值传递的特性，通常也叫以下类型为值类型。
    举例 解释 操作     bool true / false  !, &amp;amp;&amp;amp;, ||, ==, !=   int / uint(8~256) 8 默认是256位 比较，位移，算数加减乘除、取模**，位操作   address 0x7fD0030D3D21d17Fb4056DE319faD67A853b3C20 20字节，也即160位二进制码组成，代表以太坊的地址 transfer, call   contract contract MyContract {</description>
    </item>
    
    <item>
      <title>Kubernetes basics</title>
      <link>https://whisperd.tech/post/kubernetes-basics/</link>
      <pubDate>Thu, 21 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://whisperd.tech/post/kubernetes-basics/</guid>
      <description>Background &amp;amp; why kubernetes Micro services Usually we build a single &amp;ldquo;monolith&amp;rdquo; application at first time. As the business grows, the app becomes &amp;ldquo;heavy&amp;rdquo; and hard to maintain:
 Improved cost to communicate within different teams; Long enough time to finish the CI pipeline(run the test cases, packages, deployment); Hard to scale; &amp;hellip;  So we need to make big application to be small different services depends on a few principles, that&amp;rsquo;s micro services.</description>
    </item>
    
    <item>
      <title>如何部署 IOTA 的 IRI headless 全节点</title>
      <link>https://whisperd.tech/post/how-to-setup-iri/</link>
      <pubDate>Sun, 17 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://whisperd.tech/post/how-to-setup-iri/</guid>
      <description>什么是 IOTA IOTA 的设计初衷是面向未来的机器与机器、人与人、人与机器之间点对点互联互通的DLT（分布式账本技术）协议。
通过利用DAG实现了无交易费、高TPS，将whisper protocol用于消息传递，有效提高消息的可达性和私密性。
本文所关注的IRI (IOTA Reference implementation)是IOTA协议Java版本的实现，基于Rust的版本正在开发之中。
部署 IRI headless 全节点 服务器选择 目前国内的服务器提供商包括阿里云，华为，青云等， 国外的有AWS，GCP（谷歌云服务），digital ocean等，价格不等，配置大同小异，本文将会以阿里云为例。
运行 IRI 全节点配置至少是:
 1vCPU
 4G 内存
 1M 带宽
 硬盘40G目前是足够的，可以按需添加数据盘
 ECS 实例规格应为独享
  操作系统选择适合自己的Linux发行版，建议使用每种发行版的最新版本，如Ubuntu 16.04。
本文所使用配置，如下图： 服务器的基础环境准备 1.安装Git，在IRI搭建时并没有用到，之后tangle网络生成snapshot时需要：
sudo apt-get update sudo apt-get install git  2.安装screen，管理服务器终端产生的session
sudo apt-get install screen  3.安装Java， Oracle JDK，添加Oracle的包管理仓库并更新，
sudo add-apt-repository ppa:webupd8team/java sudo apt-get update  安装JDK8，
sudo apt-get install oracle-java8-installer  查看安装，</description>
    </item>
    
    <item>
      <title>理解Golang并发编程</title>
      <link>https://whisperd.tech/post/go-channel/</link>
      <pubDate>Sat, 29 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://whisperd.tech/post/go-channel/</guid>
      <description>concurrency vs parallelism 并发和并行是彼此相关的两个概念，并不能完全等价。
在程序中，并发强调的是独立执行的程序的组合；并行强调的是同时执行计算任务[1]。
计算机核心的数量决定了并行计算的能力，大多数人类作为“单核”动物(老顽童小龙女除外)，可以说自己在并发某些任务，如我在听歌写代码，但是不能说这两件事在并行，参考下图：
Golang的并发模型源于Communicating Sequential Processes (CSP)，通过提供goroutine和channel来实现并发编程模式。
Goroutine Goroutine由Go运行时创建和管理，是用于调度CPU资源的“最小单元”，和OS的线程相比更轻量[2]:
 内存消耗更低只需2kB初始栈空间，而线程初始要1Mb的空间； 由golang的运行时环境创建和销毁，更加廉价，不支持手动管理； 切换效率更高等。 Goroutine和线程的关系如下图所示：  我们可以轻松地创建成百上千的goroutine，而不会降低程序的执行效率。
通过goroutine可以让一个函数和其他的函数并行执行。可以在函数调用前面加上go关键字，方便地创建一个goroutine。
main函数本身也是一个goroutine[3]。
举例如下：
package main import &amp;quot;fmt&amp;quot; func main() { fmt.Println(&amp;quot;begin main goroutine&amp;quot;) go hello() fmt.Println(&amp;quot;end main goroutine&amp;quot;) } func hello() { fmt.Println(&amp;quot;begin hello goroutine&amp;quot;) }  输出：
begin main goroutine end main goroutine  上面的例子中，并不会输出begin hello goroutine，这是因为， 通过使用goroutine，我们不需要等待函数调用的返回结果，而会接着执行下面的代码。
可以在go hello()后面添加：
time.Sleep(1 * time.Second)  就可以正常输出begin hello goroutine。
channel Go提供了一种机制能够使goroutine之间进行通信和同步，它就是channel。</description>
    </item>
    
    <item>
      <title>Golang web 开发</title>
      <link>https://whisperd.tech/post/golang-docker-ci/</link>
      <pubDate>Wed, 05 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://whisperd.tech/post/golang-docker-ci/</guid>
      <description>背景 Web应用长期以来是Ruby、Java、PHP等开发语言的战场。
 Ruby可以实现快速原型开发，Ruby On Rails “全能”框架实现“全栈”开发，缺点有大型应用性能差、调试困难； Java 20多年的发展历程，各种第三方库、框架健全，运行效率高， 但是随着应用的功能膨胀，臃肿的get/set方法，JVM占用大量计算机资源、性能调试困难，函数式编程不友好。 PHP，TL;DR  本文实现了一个最小化web应用，以此来了解Golang web的生态，通过使用Docker隔离开发环境， 使用Posgres持久化数据，源代码请参考这里
Why Go?  性能优越 部署简单，只需要将打包好的二进制文件部署到服务器上 内置丰富的标准库，让程序员的生活变得简单美好 静态语言，类型检查 duck typing goroutine将开发人员从并发编程中解放出来 函数作为“一等公民” &amp;hellip;  Golang第三方框架选择  Web框架: Gin，性能卓越，API友好，功能完善 ORM: GORM,支持多种主流数据库方言，文档清晰 包管理工具: Glide,类似于Ruby的bundler或者NodeJS中的npm 测试工具:    GoConvey,符合BDD测试风格,支持浏览器测试结果的可视化 Testify,提供丰富的断言和Mock功能    数据库migration: migrate 日志工具: Logrus,结构化日志输出，完全兼容标准库的logger  Dockerize 开发环境 发布应用 base image Dockerfile如下:
FROM golang:1.8 # 包管理工具 RUN curl https://glide.sh/get | sh # 代码热加载 RUN go get github.</description>
    </item>
    
    <item>
      <title>理解 Javascript 的几种异步模式</title>
      <link>https://whisperd.tech/post/callback-promise/</link>
      <pubDate>Wed, 05 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://whisperd.tech/post/callback-promise/</guid>
      <description>Javacript 提供了基于回调的异步编程模式，如回调函数，Promise对象，Async Function 等。下面是我在学习过程中总结的 一些特性和使用方式。
Javascript 运行时概念  栈(Stack)  和其他语言一样, 栈保存了函数调用的层次关系, 栈中的每一块叫做一帧(frame), 最上层的那一帧, 代表了最内层的函数, 当函数返回时, 清空帧, 当调用栈中所有的帧清空(即最外层函数返回), 当前执行的代码块结束。 JS调用栈有三个特点:
  单线程, 浏览器的JS引擎本身是多线程的, 但是JS的调用栈是单线程的, 一次只能执行一段代码; 同步执行, 在栈中的任务依次执行并返回, 不能在任务之间切换 非阻塞, 在线程繁忙时, 浏览器仍然可以接收事件    堆(Heap)  堆中保存了大量的对象,垃圾收集器定期清理未被引用的对象。
 事件队列(event queue)  当调用某些Web APIs时,如DOM事件(如鼠标点击操作)、XMLHttpRequest, setTimeout()等, 会添加callback函数到event queue。
 Event loop  Event loop将event queue中按照&amp;rdquo;FIFO&amp;rdquo;的顺序将callback取出,放入栈中,callback函数返回,清空栈, 循环执行上述步骤。
MDN提供的伪代码实现如下:
while(queue.waitForMessage()) { queue.processNextMessage(); }  Callback Callback函数 和其他编程语言(Java, Ruby)不同,在JS中,函数也是对象(Function instanceof Object返回为true)。 函数是JS的&amp;rdquo;一等公民&amp;rdquo;,通俗的理解是,可以将函数作为参数传给另外一个函数,也可以将一个函数作为另一个函数的返回值。
function bar(cb) { setTimeout(cb,2000); } function foo() { console.</description>
    </item>
    
    <item>
      <title>Hackday是一种怎样的体验？</title>
      <link>https://whisperd.tech/post/hackday/</link>
      <pubDate>Sat, 07 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://whisperd.tech/post/hackday/</guid>
      <description>加入 Thoughtworks 之后，经历了REA (realestate.com.au) 三次 Hackday，感受很多，我觉得有必要和大家分享一下这么优秀的想法和活动。
什么是 hackday？ Hackday，有时也被叫做 Hackathon，是IT行业一个类似于“百米冲刺”的活动，主要目的在于围绕一个主题，进行软件设计和开发，持续时间不等，可以是一天，也可以是一周，以2~3天为多数。活动范围有企业内部、社区等。
REA的 hackday 长什么样？ 在 REA，协作和创新被视为企业的灵魂，每个季度会举办一次hackday，为期三天，除非有相当紧急的线上问题需要处理，一般来说，大部分人都是能够参与其中的。很难想象一个公司所有人三天里都在搞“飞机”，不干“正事”，但是这不也正体现了一个企业的文化、魄力和产品的稳定性吗？ hackday 流程大致是这样的，
 团队内部 brain storm，收集 idea； 投票选出意向参与的项目，分配资源； 公司范围的 Stand up，阐述 idea，并找到目标资源（UX，前端Dev，后端Dev，等等） 团队内部 Kick off，划分 story MVP 功能开发（结对编程），一般为 1.5~2天 制作 Showcase 海报 公司范围 Showcase 拉票，投票 根据项目的情况，少数会进入产品，多数会成为工作生活的小助手，解决工作生活中的痛点。  我参与的 hackday 项目 印象比较深刻的是4个:
 CI 监控  REA很多CI跑在 Bamboo 和 Buildkite上，每个平台提供的监控数据和展示层不能整合，其中一次hackday，我们就自己动手去整合两个平台的数据，外加一个数据展示的web页面，加上炫酷的动画，完美~ 并且成功的在最近一次hackday前“卖”给了别的team。
 Slack robot  监控红了，build 挂了，总得人来修吧，但是这个人呢，太忙，又或者不知道是自己在值班，怎么办呢，我们就让一个robot定时去拉build的状态，一旦红了，去slack上@他，叫醒他，“嘿，哥们，你不修，你好意思吗?”
 奔跑吧，会员卡  每当我走进xx超市、xx火锅，结账那一刻，我是拒绝的，尼玛这么点东西，怎么这么贵？现在好了， 我们搞了VIP会员卡共享的公众号，可以注册登记每个人的会员卡，可以供大家查询使用。虽然还有很多功能需要完善，但是我们已经迈出了一大步，对吗？PS: 公众号还在公司内测，一旦公开第一时间跟大家分享。
 Gulugulu  用过 Bilibili 吧，弹幕啊，吐槽啊，段子手啊，想象一下大家一起吐槽百度主站的情形， 一个字形容，爽。Gulugulu就有这样的功能，只要引入一个Javascript文件，done。具体请参考Github gulugulu和gulugulu-chrome。</description>
    </item>
    
    <item>
      <title>使用 Hexo 搭建个人博客</title>
      <link>https://whisperd.tech/post/hexo/</link>
      <pubDate>Wed, 04 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://whisperd.tech/post/hexo/</guid>
      <description>Note: 已经使用Hugo创建博客。
Hexo 是一个博客框架,支持Markdown,通过命令行可以快速部署, 有大量的主题和插件,让你的blog飞起来&amp;hellip;
安装 Hexo sudo npm install -g hexo-cli hexo -v  创建 Github blog project 个人习惯将source和deploy分开,在github上创建一个blog项目(保存源文件)和 xxx.github.io项目(用于部署Github个人主页,xxx为用户名,具体参考Github Pages)
hexo init blog cd blog npm install  Run server $ hexo s  More info: Server
设置博客页个人信息 我的配置文件 _config.yml
# Site title: Whisperd subtitle: description: make a difference author: kaichao language: timezone: Asia/Shanghai # URL ## If your site is put in a subdirectory, set url as &#39;http://yoursite.</description>
    </item>
    
  </channel>
</rss>