<!DOCTYPE html>
<html lang="en-us">
	<head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="author" content="Kaichao Sun">
<meta name="description" content="dasheng&#39;s blog">
<meta name="generator" content="Hugo 0.49.2" />
<title>理解 Javascript 的几种异步模式</title>
<link rel="shortcut icon" href="https://whisperd.tech/images/favicon.ico">
<link rel="stylesheet" href="https://whisperd.tech/css/style.css">
<link rel="stylesheet" href="https://whisperd.tech/css/highlight.css">



<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css">



<link href="https://whisperd.tech/index.xml" rel="alternate" type="application/rss+xml" title="Whisperd" />


<meta property="og:title" content="理解 Javascript 的几种异步模式" />
<meta property="og:description" content="Javacript 提供了基于回调的异步编程模式，如回调函数，Promise对象，Async Function 等。下面是我在学习过程中总结的 一些特性和使用方式。
Javascript 运行时概念  栈(Stack)  和其他语言一样, 栈保存了函数调用的层次关系, 栈中的每一块叫做一帧(frame), 最上层的那一帧, 代表了最内层的函数, 当函数返回时, 清空帧, 当调用栈中所有的帧清空(即最外层函数返回), 当前执行的代码块结束。 JS调用栈有三个特点:
  单线程, 浏览器的JS引擎本身是多线程的, 但是JS的调用栈是单线程的, 一次只能执行一段代码; 同步执行, 在栈中的任务依次执行并返回, 不能在任务之间切换 非阻塞, 在线程繁忙时, 浏览器仍然可以接收事件    堆(Heap)  堆中保存了大量的对象,垃圾收集器定期清理未被引用的对象。
 事件队列(event queue)  当调用某些Web APIs时,如DOM事件(如鼠标点击操作)、XMLHttpRequest, setTimeout()等, 会添加callback函数到event queue。
 Event loop  Event loop将event queue中按照&rdquo;FIFO&rdquo;的顺序将callback取出,放入栈中,callback函数返回,清空栈, 循环执行上述步骤。
MDN提供的伪代码实现如下:
while(queue.waitForMessage()) { queue.processNextMessage(); }  Callback Callback函数 和其他编程语言(Java, Ruby)不同,在JS中,函数也是对象(Function instanceof Object返回为true)。 函数是JS的&rdquo;一等公民&rdquo;,通俗的理解是,可以将函数作为参数传给另外一个函数,也可以将一个函数作为另一个函数的返回值。
function bar(cb) { setTimeout(cb,2000); } function foo() { console." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://whisperd.tech/post/callback-promise/" /><meta property="article:published_time" content="2017-04-05T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2017-04-05T00:00:00&#43;00:00"/>



<meta itemprop="name" content="理解 Javascript 的几种异步模式">
<meta itemprop="description" content="Javacript 提供了基于回调的异步编程模式，如回调函数，Promise对象，Async Function 等。下面是我在学习过程中总结的 一些特性和使用方式。
Javascript 运行时概念  栈(Stack)  和其他语言一样, 栈保存了函数调用的层次关系, 栈中的每一块叫做一帧(frame), 最上层的那一帧, 代表了最内层的函数, 当函数返回时, 清空帧, 当调用栈中所有的帧清空(即最外层函数返回), 当前执行的代码块结束。 JS调用栈有三个特点:
  单线程, 浏览器的JS引擎本身是多线程的, 但是JS的调用栈是单线程的, 一次只能执行一段代码; 同步执行, 在栈中的任务依次执行并返回, 不能在任务之间切换 非阻塞, 在线程繁忙时, 浏览器仍然可以接收事件    堆(Heap)  堆中保存了大量的对象,垃圾收集器定期清理未被引用的对象。
 事件队列(event queue)  当调用某些Web APIs时,如DOM事件(如鼠标点击操作)、XMLHttpRequest, setTimeout()等, 会添加callback函数到event queue。
 Event loop  Event loop将event queue中按照&rdquo;FIFO&rdquo;的顺序将callback取出,放入栈中,callback函数返回,清空栈, 循环执行上述步骤。
MDN提供的伪代码实现如下:
while(queue.waitForMessage()) { queue.processNextMessage(); }  Callback Callback函数 和其他编程语言(Java, Ruby)不同,在JS中,函数也是对象(Function instanceof Object返回为true)。 函数是JS的&rdquo;一等公民&rdquo;,通俗的理解是,可以将函数作为参数传给另外一个函数,也可以将一个函数作为另一个函数的返回值。
function bar(cb) { setTimeout(cb,2000); } function foo() { console.">


<meta itemprop="datePublished" content="2017-04-05T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2017-04-05T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="957">



<meta itemprop="keywords" content="" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="理解 Javascript 的几种异步模式"/>
<meta name="twitter:description" content="Javacript 提供了基于回调的异步编程模式，如回调函数，Promise对象，Async Function 等。下面是我在学习过程中总结的 一些特性和使用方式。
Javascript 运行时概念  栈(Stack)  和其他语言一样, 栈保存了函数调用的层次关系, 栈中的每一块叫做一帧(frame), 最上层的那一帧, 代表了最内层的函数, 当函数返回时, 清空帧, 当调用栈中所有的帧清空(即最外层函数返回), 当前执行的代码块结束。 JS调用栈有三个特点:
  单线程, 浏览器的JS引擎本身是多线程的, 但是JS的调用栈是单线程的, 一次只能执行一段代码; 同步执行, 在栈中的任务依次执行并返回, 不能在任务之间切换 非阻塞, 在线程繁忙时, 浏览器仍然可以接收事件    堆(Heap)  堆中保存了大量的对象,垃圾收集器定期清理未被引用的对象。
 事件队列(event queue)  当调用某些Web APIs时,如DOM事件(如鼠标点击操作)、XMLHttpRequest, setTimeout()等, 会添加callback函数到event queue。
 Event loop  Event loop将event queue中按照&rdquo;FIFO&rdquo;的顺序将callback取出,放入栈中,callback函数返回,清空栈, 循环执行上述步骤。
MDN提供的伪代码实现如下:
while(queue.waitForMessage()) { queue.processNextMessage(); }  Callback Callback函数 和其他编程语言(Java, Ruby)不同,在JS中,函数也是对象(Function instanceof Object返回为true)。 函数是JS的&rdquo;一等公民&rdquo;,通俗的理解是,可以将函数作为参数传给另外一个函数,也可以将一个函数作为另一个函数的返回值。
function bar(cb) { setTimeout(cb,2000); } function foo() { console."/>
<meta name="twitter:site" content="@https://twitter.com/SunWillsuna"/>


    </head>
<body>
    <nav class="main-nav">
	
		<a href='https://whisperd.tech'> <span class="arrow">←</span>Home</a>
	

	
 		<a href='/about/'>About</a>
  	

	<a href="/resume">Resume</a>

	
		<a class="cta" href="https://whisperd.tech/index.xml">Subscribe</a>
	
</nav>

    <section id="wrapper">
        
        

<article class="post">
    <header>
        <h1>理解 Javascript 的几种异步模式</h1>
        <h2 class="subtitle"></h2>
        <h2 class="headline">
        April 5, 2017
        <br>
        
        </h2>
    </header>

    <aside>
        <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#javascript-运行时概念">Javascript 运行时概念</a></li>
<li><a href="#callback">Callback</a>
<ul>
<li><a href="#callback函数">Callback函数</a></li>
<li><a href="#callback-hell">Callback hell</a></li>
</ul></li>
<li><a href="#promise">Promise</a>
<ul>
<li><a href="#什么是promise">什么是Promise</a></li>
<li><a href="#promise-api">Promise API</a>
<ul>
<li><a href="#promise状态">Promise状态</a></li>
<li><a href="#promise方法">Promise方法</a></li>
</ul></li>
<li><a href="#simple-example">Simple Example</a>
<ul>
<li><a href="#构造一个-promise-通过-then-函数取值">构造一个 Promise, 通过 <code>then</code> 函数取值:</a></li>
<li><a href="#then-的回调函数有返回值时-返回一个-relove-该值的-promise"><code>then</code> 的回调函数有返回值时,返回一个 relove 该值的 Promise:</a></li>
<li><a href="#then-的回调函数中没有返回值-调用-then-函数返回一个promise-其relove的值为-undefined"><code>then</code>的回调函数中没有返回值,调用<code>then</code>函数返回一个Promise,其relove的值为<code>undefined</code></a></li>
<li><a href="#同一个promise被多次使用时-执行顺序为-then-调用的先后顺序">同一个Promise被多次使用时,执行顺序为<code>then</code>调用的先后顺序:</a></li>
<li><a href="#promise-all-异步执行">Promise.all (异步执行)</a></li>
<li><a href="#promise-race-异步执行">Promise.race (异步执行)</a></li>
</ul></li>
<li><a href="#promise-实现">Promise 实现</a></li>
</ul></li>
<li><a href="#generator">Generator</a>
<ul>
<li><a href="#simple-example-1">Simple example</a></li>
<li><a href="#理解双向消息传递">理解双向消息传递</a></li>
<li><a href="#其他api">其他API</a></li>
<li><a href="#generator结合promise实现异步控制流">Generator结合Promise实现异步控制流</a></li>
</ul></li>
<li><a href="#async-function-es7">Async Function (ES7)</a></li>
<li><a href="#总结">总结</a></li>
<li><a href="#reference">Reference</a></li>
</ul></li>
</ul>
</nav>
    </aside>

    <section id="post-body">
        

<p>Javacript 提供了基于回调的异步编程模式，如回调函数，Promise对象，Async Function 等。下面是我在学习过程中总结的
一些特性和使用方式。</p>

<h2 id="javascript-运行时概念">Javascript 运行时概念</h2>

<p><img src="/static/callback-promise/js-runtime-concept.svg" alt="js runtime" /></p>

<ul>
<li>栈(Stack)</li>
</ul>

<p>和其他语言一样, 栈保存了函数调用的层次关系, 栈中的每一块叫做一帧(frame), 最上层的那一帧, 代表了最内层的函数,
当函数返回时, 清空帧, 当调用栈中所有的帧清空(即最外层函数返回), 当前执行的代码块结束。
JS调用栈有三个特点:</p>

<blockquote>
<ol>
<li>单线程, 浏览器的JS引擎本身是多线程的, 但是JS的调用栈是单线程的, 一次只能执行一段代码;</li>
<li>同步执行, 在栈中的任务依次执行并返回, 不能在任务之间切换</li>
<li>非阻塞, 在线程繁忙时, 浏览器仍然可以接收事件</li>
</ol>
</blockquote>

<ul>
<li>堆(Heap)</li>
</ul>

<p>堆中保存了大量的对象,垃圾收集器定期清理未被引用的对象。</p>

<ul>
<li>事件队列(event queue)</li>
</ul>

<p>当调用某些Web APIs时,如DOM事件(如鼠标点击操作)、XMLHttpRequest, setTimeout()等,
会添加callback函数到event queue。</p>

<ul>
<li>Event loop</li>
</ul>

<p>Event loop将event queue中按照&rdquo;FIFO&rdquo;的顺序将callback取出,放入栈中,callback函数返回,清空栈,
循环执行上述步骤。</p>

<p>MDN提供的伪代码实现如下:</p>

<pre><code>while(queue.waitForMessage()) {
	queue.processNextMessage();
}
</code></pre>

<hr />

<h2 id="callback">Callback</h2>

<h3 id="callback函数">Callback函数</h3>

<p>和其他编程语言(Java, Ruby)不同,在JS中,函数也是对象(<code>Function instanceof Object</code>返回为<code>true</code>)。
函数是JS的&rdquo;一等公民&rdquo;,通俗的理解是,可以将函数作为参数传给另外一个函数,也可以将一个函数作为另一个函数的返回值。</p>

<pre><code class="language-javascript">function bar(cb) {
	setTimeout(cb,2000);
}

function foo() {
	console.log(&quot;hehe&quot;)
}

bar(foo)
</code></pre>

<p>上面的代码中,foo就是callback函数,上述代码的执行过程大致如下图所示:</p>

<p><img src="/static/callback-promise/event-queue.svg" alt="event queue" /></p>

<h3 id="callback-hell">Callback hell</h3>

<p>思考如下代码:</p>

<pre><code class="language-javascript">listen( &quot;click&quot;, function handler(evt){
	setTimeout( function request(){
		ajax( &quot;http://some.url.1&quot;, function response(text){
			if (text == &quot;hello&quot;) {
				handler();
			}
			else if (text == &quot;world&quot;) {
				request();
			}
		} );
	}, 2000) ;
} );
</code></pre>

<p>这样的代码常常被称作&rdquo;callback hell&rdquo;,也被称为&rdquo;倒金字塔&rdquo;。
但是callback hell,不止看上去的缩进/嵌套问题。代码层面的问题,
可以通过重构,将回调函数作为参数传递解决:</p>

<pre><code class="language-javascript">// step 1
listen( &quot;click&quot;, handler );

// step 2
function handler() {
	setTimeout( request, 500 );
}

// step 3
function request(){
	ajax( &quot;http://some.url.1&quot;, response );
}

// step 4
function response(text){
	if (text == &quot;hello&quot;) {
		handler();
	}
	else if (text == &quot;world&quot;) {
		request();
	}
}
</code></pre>

<p>这样做的结果很明显,没有了大段的嵌套代码,但依然有很多问题没有解决:</p>

<ol>
<li>数据流出现在多个函数之间,需要跳转多个函数才能看清楚,
当代码结构变得复杂,清晰的数据流更难以获取;</li>
<li>各个步骤之间通过hard code进行连接,无法复用;</li>
<li>在每个步骤都要对异常进行处理,产生逻辑重复的代码等;</li>
</ol>

<p><strong>Last but most important</strong>, callback 将控制权交给了第三方,由此产生一系列的信任问题,
大部分情况下,我们不需要过多的考虑信任问题(如过早/过晚回调、多次回调等),但是也只是还没有出现问题而已。</p>

<hr />

<h2 id="promise">Promise</h2>

<h3 id="什么是promise">什么是Promise</h3>

<p>Promise并不是Javascript独有的,在多种编程语言中都存在类似的概念如Java/Scala中的Future,
在1976年前后已经陆续提出了这些概念。</p>

<p>MDN的描述:</p>

<blockquote>
<p>A Promise is a proxy for a value not necessarily known when the promise is created</p>
</blockquote>

<p>Promise/A+:</p>

<blockquote>
<p>A promise represents the eventual result of an asynchronous operation.</p>
</blockquote>

<p>我的理解:</p>

<blockquote>
<p>Promise对异步/同步操作进行动态代理, 并通过规定的 <code>then</code> 函数访问异步/同步操作的结果, 访问的过程是异步(通过回调函数)的。
由于 chainable、immutable、规范化的异常处理等特点, 使异步代码符合人的思考方式, 弥补了回调函数的一些不足(如 callback hell, 多次回调等)。
但是从实现来看, Promise 的根本还是回调, 只是通过巧妙标准的API简化了整个流程。</p>
</blockquote>

<h3 id="promise-api">Promise API</h3>

<p>Promise API流程如下:</p>

<p><img src="/static/callback-promise/promise.png" alt="Promise API flow" /></p>

<h4 id="promise状态">Promise状态</h4>

<ul>
<li>pending: 初始状态</li>
<li>fulfilled: 成功状态</li>
<li>rejected: 失败状态</li>
</ul>

<h4 id="promise方法">Promise方法</h4>

<pre><code class="language-javascript">Promise.all([promise1, promise2, …]);
Promise.race([promise1, promise2, …]);
Promise.reject(value);
Promise.resolve(value);
Promise.catch(onRejection);
Promise.then(onFulFillment, onRejection);
</code></pre>

<h3 id="simple-example">Simple Example</h3>

<h4 id="构造一个-promise-通过-then-函数取值">构造一个 Promise, 通过 <code>then</code> 函数取值:</h4>

<pre><code class="language-javascript">var myPromise = new Promise((resolve, reject) =&gt; {
    setTimeout(function() {
        resolve(&quot;success&quot;);
    }, 3000);
});

myPromise.then((msg) =&gt; {
   console.log(&quot;Yay, &quot; + msg);
});

console.log(&quot;i am not promise&quot;);
</code></pre>

<p>Console输出:</p>

<pre><code>i am not promise
Yay, success
</code></pre>

<h4 id="then-的回调函数有返回值时-返回一个-relove-该值的-promise"><code>then</code> 的回调函数有返回值时,返回一个 relove 该值的 Promise:</h4>

<pre><code class="language-javascript">var myPromise = new Promise((resolve, reject) =&gt; {
    setTimeout(function() {
        resolve(&quot;success&quot;);
    }, 3000);
});

var myPromise2 = myPromise.then((msg) =&gt; {
   console.log(&quot;Yay, &quot; + msg);
   return &quot;success 2&quot;;
});

myPromise2.then((msg) =&gt; {
    console.log(&quot;Hey, &quot; + msg);
});

console.log(&quot;i am not promise&quot;);
</code></pre>

<p>Console输出:</p>

<pre><code>i am not promise
Yay, success
Hey, success 2
</code></pre>

<h4 id="then-的回调函数中没有返回值-调用-then-函数返回一个promise-其relove的值为-undefined"><code>then</code>的回调函数中没有返回值,调用<code>then</code>函数返回一个Promise,其relove的值为<code>undefined</code></h4>

<pre><code class="language-javascript">var myPromise = new Promise((resolve, reject) =&gt; {
    setTimeout(function() {
        resolve(&quot;success&quot;);
    }, 3000);
});

var myPromise2 = myPromise.then((msg) =&gt; {
   console.log(&quot;Yay, &quot; + msg);
});

myPromise2.then((msg) =&gt; {
    console.log(&quot;Hey, &quot; + msg);
});

console.log(&quot;i am not promise&quot;);
</code></pre>

<p>Console输出:</p>

<pre><code>i am not promise
Yay, success
Hey, undefined
</code></pre>

<h4 id="同一个promise被多次使用时-执行顺序为-then-调用的先后顺序">同一个Promise被多次使用时,执行顺序为<code>then</code>调用的先后顺序:</h4>

<pre><code class="language-javascript">var myPromise = new Promise((resolve, reject) =&gt; {
    setTimeout(function() {
        resolve(&quot;success&quot;);
    }, 3000);
});

myPromise.then((msg) =&gt; {
   console.log(&quot;Yay, &quot; + msg);
});

myPromise.then((msg) =&gt; {
    console.log(&quot;Hey, &quot; + msg);
})

myPromise.then((msg) =&gt; {
    console.log(&quot;bazhahei, &quot; + msg);
})
console.log(&quot;i am not promise&quot;);
</code></pre>

<p>Console输出</p>

<pre><code>i am not promise
Yay, success
Hey, success
bazhahei, success
</code></pre>

<h4 id="promise-all-异步执行">Promise.all (异步执行)</h4>

<pre><code class="language-javascript">var p1 = Promise.resolve('haha');
var p2 = Promise.resolve('heheda');

var p3 = Promise.all([p1,p2]);
p3.then((msg)=&gt;{
    console.log(p3);
    console.log(msg);
});
console.log(p3)
var p2_reject = Promise.reject('err');

var p4 = Promise.all([p1,p2_reject]);
p4.then(null,(msg)=&gt;console.log(msg));
</code></pre>

<p>Console输出</p>

<pre><code>Promise {[[PromiseStatus]]: &quot;pending&quot;, [[PromiseValue]]: undefined}
Promise {[[PromiseStatus]]: &quot;resolved&quot;, [[PromiseValue]]: Array[2]}
[&quot;haha&quot;, &quot;heheda&quot;]
err
</code></pre>

<h4 id="promise-race-异步执行">Promise.race (异步执行)</h4>

<pre><code class="language-javascript">var p1= Promise.reject('haha')
console.log(&quot;didi&quot;)
var p2 = Promise.resolve('heheda')
var p3 = Promise.race([p1,p2]).then(
    (msg)=&gt;console.log(msg), (reason)=&gt;console.log(reason)
)

console.log(p3)
console.log(&quot;over&quot;)
</code></pre>

<p>Console输出</p>

<pre><code>Promise {[[PromiseStatus]]: &quot;pending&quot;, [[PromiseValue]]: undefined}
over
haha
</code></pre>

<h3 id="promise-实现">Promise 实现</h3>

<ol>
<li>一个简易的Promise的实现参考<a href="https://gist.github.com/unscriptable/814052">这里</a></li>
<li><a href="http://www.mattgreer.org/articles/promises-in-wicked-detail/">http://www.mattgreer.org/articles/promises-in-wicked-detail/</a></li>
<li><a href="https://github.com/cujojs/when">cujojs/when</a></li>
</ol>

<hr />

<h2 id="generator">Generator</h2>

<p>Generator函数是一种特殊的函数,它不是 <code>run to completion</code> 的,而是可以多次分段执行,
通过双向消息传递(2-way messsage passing)实现状态机、异步流程控制等多种功能。</p>

<p>调用generator函数可以返回一个generator对象（既是iterator也是iterable）。
注：</p>

<blockquote>
<p>Iterator: 一个实现了next函数的对象，next返回返回值为<code>{value: xxx, done: true/false}</code>
  Iterable: 一个含有属性为<code>Symbol.iterator</code>的对象，<code>Symbol.iterator</code>是一个可以返回上述Iterator对象的函数。</p>
</blockquote>

<h3 id="simple-example-1">Simple example</h3>

<p><code>yield</code> 使用：</p>

<pre><code class="language-javascript">function* generator() {
  yield 1;
  yield 2;
  yield 3;
}
var g1 = generator()
console.log(g1.next())
console.log(g1.next())
console.log(g1.next())
console.log(g1.next())
</code></pre>

<p>console 输出</p>

<pre><code>{value: 1, done: false}
{value: 2, done: false}
{value: 3, done: false}
{value: undefined, done: true}
</code></pre>

<p><code>yield*</code>使用,将控制权交给另外一个Iterable对象：</p>

<pre><code class="language-javascript">function* generator() {
  yield 1;
  yield* [2.1,2.2,2.3];
  yield 3;
}
var g2 = generator()
console.log(g2.next())
console.log(g2.next())
console.log(g2.next())
console.log(g2.next())
console.log(g2.next())
console.log(g2.next())
</code></pre>

<p>输出：</p>

<pre><code>{value: 1, done: false}
{value: 2.1, done: false}
{value: 2.2, done: false}
{value: 2.3, done: false}
{value: 3, done: false}
{value: undefined, done: true}
</code></pre>

<p>上面两个例子，只用到了单向消息传递，即只关注<code>next()</code>的返回值，下面让我举一个双向消息传递的栗子：</p>

<pre><code class="language-javascript">function* twoWayMessagePassing() {
  let a = yield 1;
  let b = yield 2;
  return a + b;
}

var g3 = twoWayMessagePassing()
console.log(g3.next());
console.log(g3.next(3));
console.log(g3.next(4));
</code></pre>

<p>输出：</p>

<pre><code>{value: 1, done: false}
{value: 2, done: false}
{value: 7, done: true}
</code></pre>

<h3 id="理解双向消息传递">理解双向消息传递</h3>

<p>根据上述第三个例子，画图如下,
每一次<code>next</code>函数执行一段代码块时，将参数赋给代码块开始处的yield表达式(如果有的话)，并将代码块结束处的yield/return表达式的值作为<code>next</code>函数的返回值。</p>

<p><img src="/static/callback-promise/two-way-message-passing.svg" alt="two-way-message-passing" /></p>

<h3 id="其他api">其他API</h3>

<pre><code class="language-javascript">Generator.prototype.return()
Generator.prototype.throw()
</code></pre>

<h3 id="generator结合promise实现异步控制流">Generator结合Promise实现异步控制流</h3>

<p>一个简易的控制方法如下，需要 <strong>手动迭代</strong>：</p>

<pre><code class="language-javascript">function foo(a,b) {
    return new Promise((resolve)=&gt;{
        setTimeout(()=&gt;{
            resolve(a+b);
        },2000);
    })
}

function* gen() {
    try {
        var sum1 = yield foo(3, 6);
        var sum2 = yield foo(7, 9);
        return sum1 + sum2;
    } catch (err) {
        console.log(err);
    }
}

var it = gen();
var p = it.next().value

p.then((msg)=&gt;{
    return it.next(msg).value
}).then((msg)=&gt;{
    return it.next(msg).value
}).then((msg)=&gt;{
    console.log(msg)
})
</code></pre>

<p>输出：<code>25</code>。</p>

<p>修改上述过程实现 <strong>自动迭代</strong>：</p>

<pre><code class="language-javascript">var isPromise = (obj) =&gt; typeof obj !== 'undefined' &amp;&amp;
  typeof obj.then === 'function';

var next = (iter, callback, prev = undefined) =&gt; {
  const item = iter.next(prev);
  const value = item.value;

  if (item.done) return callback(prev);

  if (isPromise(value)) {
    value.then(val =&gt; {
      setTimeout(() =&gt; next(iter, callback, val),0);
    });
  } else {
    setTimeout(() =&gt; next(iter, callback, value),0);
  }
};

var gensync = (fn) =&gt; {
  return (...args) =&gt;  {
    return new Promise(resolve =&gt; {
      next(fn(...args), val =&gt; resolve(val));
    })
  }
};

var foo = (a, b) =&gt; new Promise((resolve) =&gt; {
  setTimeout(()=&gt;{
      resolve(a+b);
  },2000);
});

var asyncFunc = gensync(function* () {
  var result1 = yield foo(3, 6); // returns promise
  var result2 = yield foo(7, 9) // returns another promise
  // waits for promise and uses promise result
  yield result1 + result2;
});

asyncFunc()
  .then(val =&gt; console.log(val));
</code></pre>

<p>输出：<code>25</code>。</p>

<hr />

<h2 id="async-function-es7">Async Function (ES7)</h2>

<p>Async Function可以将异步流程以顺序执行的方式来描述，增强了可读性，其实就是上述Generator和Promise结合的 <em>语法糖</em>
上述代码可以写成以下形式：</p>

<pre><code class="language-javascript">function foo(a,b) {
    return new Promise((resolve)=&gt;{
        setTimeout(()=&gt;{
            resolve(a+b);
        }, 2000);
    })
}

async function sum() {
    var sum1 = await foo(3, 6);
    var sum2 = await foo(7, 9);
    return sum1 + sum2;
}

sum().then(v =&gt; {console.log(v)})
</code></pre>

<p>输出: <code>25</code>。</p>

<p><code>await</code> 表达式&rdquo;暂停&rdquo;了async函数的执行，等待某个Promise变为fulfilled/rejected的状态，
此时，再继续执行async函数后面的代码块，最终返回一个Promise对象。</p>

<p>由此，上述async函数<code>sum</code>可以优化为：</p>

<pre><code class="language-javascript">async function sum() {
    var sum1 = foo(3, 6);
    var sum2 = foo(7, 9);
    return await sum1 + await sum2;
}
</code></pre>

<h2 id="总结">总结</h2>

<p>Javascript越来越广泛的应用于Web前后端的开发工作之中，合理使用JS的异步编程模式，可以提高程序的性能，增加代码的可维护性和可读性。</p>

<h2 id="reference">Reference</h2>

<p>[1] <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/EventLoop">https://developer.mozilla.org/en/docs/Web/JavaScript/EventLoop</a><br />
[2] <a href="http://www.sohamkamani.com/blog/2016/03/14/wrapping-your-head-around-async-programming/">How is javascript asynchronous AND single threaded?</a><br />
[3] <a href="https://github.com/getify/You-Dont-Know-JS">You-Dont-Know-JS</a><br />
[4] <a href="https://tc39.github.io/ecma262/">ECMAScript® 2017 Language Specification</a><br />
[5] <a href="http://www.mattgreer.org/articles/promises-in-wicked-detail/">http://www.mattgreer.org/articles/promises-in-wicked-detail/</a><br />
[6] <a href="https://promisesaplus.com">Promise/A+</a><br />
[7] <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">Iteration protocol</a></p>

    </section>
</article>

<footer id="post-meta" class="clearfix">
    <a href="https://twitter.com/SunWillsuna">
    <img class="avatar" src="https://whisperd.tech/images/avatar.png">
    <div>
        <span class="dark">Kaichao Sun</span>
        <span>Mark it down</span>
    </div>
    </a>
    <section id="sharing">
        <a class="twitter" href="https://twitter.com/intent/tweet?text=https%3a%2f%2fwhisperd.tech%2fpost%2fcallback-promise%2f - %e7%90%86%e8%a7%a3%20Javascript%20%e7%9a%84%e5%87%a0%e7%a7%8d%e5%bc%82%e6%ad%a5%e6%a8%a1%e5%bc%8f by @SunWillsuna"><span class="icon-twitter"> tweet</span></a>

<a class="facebook" href="#" onclick="
    window.open(
      'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
      'facebook-share-dialog',
      'width=626,height=436');
    return false;"><span class="icon-facebook-rect"> Share</span>
</a>

    </section>
</footer>

<div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "whisperd" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

<ul id="post-list" class="archive readmore">
    <h3>Read more</h3>

    
    
    
        <li>
            <a href="/post/error_handling_in_scala/">Understand Error Handling in Scala<aside class="dates">Jan 17 2019</aside></a>
        </li>
    
        <li>
            <a href="/post/shell-cheat-sheet/">Cheat sheet for Shell programming<aside class="dates">Jan 2 2019</aside></a>
        </li>
    
        <li>
            <a href="/post/common-cli-cheat-sheet/">Cheat sheet for common used CLI<aside class="dates">Jan 2 2019</aside></a>
        </li>
    
        <li>
            <a href="/post/understand-monad/">Understand Monad in Functional Programming<aside class="dates">Oct 13 2018</aside></a>
        </li>
    
        <li>
            <a href="/post/solidity-basics/">Understanding smart contracts<aside class="dates">Jun 22 2018</aside></a>
        </li>
    
        <li>
            <a href="/post/kubernetes-basics/">Kubernetes basics<aside class="dates">Jun 21 2018</aside></a>
        </li>
    
        <li>
            <a href="/post/how-to-setup-iri/">如何部署 IOTA 的 IRI headless 全节点<aside class="dates">Dec 17 2017</aside></a>
        </li>
    
        <li>
            <a href="/post/go-channel/">理解Golang并发编程<aside class="dates">Jul 29 2017</aside></a>
        </li>
    
        <li>
            <a href="/post/golang-docker-ci/">Golang web 开发<aside class="dates">Jul 5 2017</aside></a>
        </li>
    
        <li>
            <a href="/post/hackday/">Hackday是一种怎样的体验？<aside class="dates">Jan 7 2017</aside></a>
        </li>
    
</ul>



        <footer id="footer">
    
        <div id="social">

	
	
    <a class="symbol" href="https://github.com/dashengSun">
        <i class="fa fa-github"></i>
    </a>
    
    <a class="symbol" href="https://twitter.com/SunWillsuna">
        <i class="fa fa-twitter"></i>
    </a>
    


</div>

    
    <p class="small">
    
        © Copyright 2019 Kaichao Sun
    
    </p>
</footer>

    </section>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script src="https://whisperd.tech/js/main.js"></script>
<script src="https://whisperd.tech/js/highlight.js"></script>
<script src="https://whisperd.tech/js/fix-toc.js"></script>
<script src="https://whisperd.tech/js/gulugulu.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-2513693433628672",
    enable_page_level_ads: true
  });
</script>




<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-128168145-1', 'auto');
	
	ga('send', 'pageview');
}
</script>


</body>
</html>
