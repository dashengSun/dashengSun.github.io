<!DOCTYPE html>
<html lang="en-us">
	<head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="author" content="Kaichao Sun">
<meta name="description" content="kaichao&#39;s blog">
<meta name="generator" content="Hugo 0.58.3" />
<title>抛硬币游戏(二)：编写测试和UI</title>
<link rel="shortcut icon" href="https://whisperd.tech/images/favicon.ico">
<link rel="stylesheet" href="https://whisperd.tech/css/style.css">
<link rel="stylesheet" href="https://whisperd.tech/css/highlight.css">



<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css">



<link href="https://whisperd.tech/index.xml" rel="alternate" type="application/rss+xml" title="Whisperd" />


<meta property="og:title" content="抛硬币游戏(二)：编写测试和UI" />
<meta property="og:description" content="在之前的文章 Substrate应用 - 抛硬币游戏（一），我们完成了runtime的开发，从而实现了一个自定义功能（即抛硬币游戏）的区块链网络。现在让我们来看一下如何编写测试代码和UI，你也可以直接看最终的模块代码和UI代码。
测试 重要性 为功能模块编写测试，是软件开发过程中不可缺省的一个环节，完备的测试能够：
 确保代码的执行符合预期； 增强重构时的信心； 从代码的使用角度，提升代码的设计等。  通常情况下，测试可以分为以下几种：
 单元测试，mock实现代码中的依赖如其它功能模块，仅测试当前函数的功能； 集成测试，不mock实现代码中的依赖，对多个功能模块整体考虑，进行测试； End to End 测试，是面向当前系统与依赖的第三方服务之间的测试。  当我们在使用Substrate进行开发时，主要会使用到单元测试和集成测试的方法，对于不同的场景，可以按需选择。一个最佳实践是，确保自定义的runtime模块有良好的测试覆盖。
Rust 测试代码 Rust测试代码通常会和实现代码放在同一个文件或相同的目录下，取决于测试代码的数量，更多内容可以参考Rust book。下面是一个简单的测试用例：
pub fn add_two(a: i32) -&gt; i32 { a &#43; 2 } #[cfg(test)] mod tests { use super::*; #[test] fn test_add_two() { assert_eq!(4, add_two(2)); } }  一些需要注意的点包括：
 测试代码使用属性#[cfg(test)]进行标识 use super::*用来引入当前模块的功能代码 测试函数通过属性#[test]进行标识 断言方式有：  表达式的值为true：assert!(expression) 表达式的值是期望的值：assert_eq!(expected, expression) 表达式的值不是其它不相关的值：assert_ne!(other, expression) 异常发生：#[should_panic] Substrate提供了自定义的断言： 结果为Ok(())：assert_ok!(expreesion) 结果为Err(error_info)：assert_err!(expression, error_info) 结果为Err(error_info)，并且不修改存储状态：assert_noop!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://whisperd.tech/post/coin_flip_test_and_ui/" />
<meta property="article:published_time" content="2019-10-03T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-10-03T00:00:00+00:00" />


<meta itemprop="name" content="抛硬币游戏(二)：编写测试和UI">
<meta itemprop="description" content="在之前的文章 Substrate应用 - 抛硬币游戏（一），我们完成了runtime的开发，从而实现了一个自定义功能（即抛硬币游戏）的区块链网络。现在让我们来看一下如何编写测试代码和UI，你也可以直接看最终的模块代码和UI代码。
测试 重要性 为功能模块编写测试，是软件开发过程中不可缺省的一个环节，完备的测试能够：
 确保代码的执行符合预期； 增强重构时的信心； 从代码的使用角度，提升代码的设计等。  通常情况下，测试可以分为以下几种：
 单元测试，mock实现代码中的依赖如其它功能模块，仅测试当前函数的功能； 集成测试，不mock实现代码中的依赖，对多个功能模块整体考虑，进行测试； End to End 测试，是面向当前系统与依赖的第三方服务之间的测试。  当我们在使用Substrate进行开发时，主要会使用到单元测试和集成测试的方法，对于不同的场景，可以按需选择。一个最佳实践是，确保自定义的runtime模块有良好的测试覆盖。
Rust 测试代码 Rust测试代码通常会和实现代码放在同一个文件或相同的目录下，取决于测试代码的数量，更多内容可以参考Rust book。下面是一个简单的测试用例：
pub fn add_two(a: i32) -&gt; i32 { a &#43; 2 } #[cfg(test)] mod tests { use super::*; #[test] fn test_add_two() { assert_eq!(4, add_two(2)); } }  一些需要注意的点包括：
 测试代码使用属性#[cfg(test)]进行标识 use super::*用来引入当前模块的功能代码 测试函数通过属性#[test]进行标识 断言方式有：  表达式的值为true：assert!(expression) 表达式的值是期望的值：assert_eq!(expected, expression) 表达式的值不是其它不相关的值：assert_ne!(other, expression) 异常发生：#[should_panic] Substrate提供了自定义的断言： 结果为Ok(())：assert_ok!(expreesion) 结果为Err(error_info)：assert_err!(expression, error_info) 结果为Err(error_info)，并且不修改存储状态：assert_noop!">


<meta itemprop="datePublished" content="2019-10-03T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2019-10-03T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="673">



<meta itemprop="keywords" content="" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="抛硬币游戏(二)：编写测试和UI"/>
<meta name="twitter:description" content="在之前的文章 Substrate应用 - 抛硬币游戏（一），我们完成了runtime的开发，从而实现了一个自定义功能（即抛硬币游戏）的区块链网络。现在让我们来看一下如何编写测试代码和UI，你也可以直接看最终的模块代码和UI代码。
测试 重要性 为功能模块编写测试，是软件开发过程中不可缺省的一个环节，完备的测试能够：
 确保代码的执行符合预期； 增强重构时的信心； 从代码的使用角度，提升代码的设计等。  通常情况下，测试可以分为以下几种：
 单元测试，mock实现代码中的依赖如其它功能模块，仅测试当前函数的功能； 集成测试，不mock实现代码中的依赖，对多个功能模块整体考虑，进行测试； End to End 测试，是面向当前系统与依赖的第三方服务之间的测试。  当我们在使用Substrate进行开发时，主要会使用到单元测试和集成测试的方法，对于不同的场景，可以按需选择。一个最佳实践是，确保自定义的runtime模块有良好的测试覆盖。
Rust 测试代码 Rust测试代码通常会和实现代码放在同一个文件或相同的目录下，取决于测试代码的数量，更多内容可以参考Rust book。下面是一个简单的测试用例：
pub fn add_two(a: i32) -&gt; i32 { a &#43; 2 } #[cfg(test)] mod tests { use super::*; #[test] fn test_add_two() { assert_eq!(4, add_two(2)); } }  一些需要注意的点包括：
 测试代码使用属性#[cfg(test)]进行标识 use super::*用来引入当前模块的功能代码 测试函数通过属性#[test]进行标识 断言方式有：  表达式的值为true：assert!(expression) 表达式的值是期望的值：assert_eq!(expected, expression) 表达式的值不是其它不相关的值：assert_ne!(other, expression) 异常发生：#[should_panic] Substrate提供了自定义的断言： 结果为Ok(())：assert_ok!(expreesion) 结果为Err(error_info)：assert_err!(expression, error_info) 结果为Err(error_info)，并且不修改存储状态：assert_noop!"/>
<meta name="twitter:site" content="@https://twitter.com/kaichaosun"/>


    </head>
<body>
    <nav class="main-nav">
	
		<a href='https://whisperd.tech'> <span class="arrow">←</span>Home</a>
	

	
 		<a href='/about/'>About</a>
  	

	

	
		<a class="cta" href="https://whisperd.tech/index.xml">Subscribe</a>
	
</nav>

    <section id="wrapper">
        
        

<article class="post">
    <header>
        <h1>抛硬币游戏(二)：编写测试和UI</h1>
        <h2 class="subtitle"></h2>
        <h2 class="headline">
        October 3, 2019
        <br>
        
        </h2>
    </header>

    <aside>
        <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#测试">测试</a>
<ul>
<li><a href="#重要性">重要性</a></li>
<li><a href="#rust-测试代码">Rust 测试代码</a></li>
<li><a href="#runtime-测试">Runtime 测试</a></li>
<li><a href="#初始化genesisconfig">初始化GenesisConfig</a></li>
<li><a href="#测试set-payment函数">测试set_payment函数</a></li>
<li><a href="#测试play函数">测试play函数</a></li>
</ul></li>
<li><a href="#ui开发">UI开发</a>
<ul>
<li><a href="#初始化api和状态">初始化API和状态</a></li>
<li><a href="#状态更新">状态更新</a></li>
<li><a href="#ui组件">UI组件</a></li>
</ul></li>
<li><a href="#总结">总结</a></li>
</ul></li>
</ul>
</nav>
    </aside>
    

    <section id="post-body">
        

<p>在之前的文章 <a href="https://zhuanlan.zhihu.com/p/76815437">Substrate应用 - 抛硬币游戏（一）</a>，我们完成了runtime的开发，从而实现了一个自定义功能（即抛硬币游戏）的区块链网络。现在让我们来看一下如何编写测试代码和UI，你也可以直接看最终的<a href="https://github.com/kaichaosun/substrate-coin-flip/blob/master/runtime/src/mymodule.rs">模块代码</a>和<a href="https://github.com/kaichaosun/substrate-front-end-template/blob/coinflip/src/CoinFlipGame.js">UI代码</a>。</p>

<h2 id="测试">测试</h2>

<h3 id="重要性">重要性</h3>

<p>为功能模块编写测试，是软件开发过程中不可缺省的一个环节，完备的测试能够：</p>

<ul>
<li>确保代码的执行符合预期；</li>
<li>增强重构时的信心；</li>
<li>从代码的使用角度，提升代码的设计等。</li>
</ul>

<p>通常情况下，测试可以分为以下几种：</p>

<ul>
<li>单元测试，mock实现代码中的依赖如其它功能模块，仅测试当前函数的功能；</li>
<li>集成测试，不mock实现代码中的依赖，对多个功能模块整体考虑，进行测试；</li>
<li>End to End 测试，是面向当前系统与依赖的第三方服务之间的测试。</li>
</ul>

<p>当我们在使用Substrate进行开发时，主要会使用到单元测试和集成测试的方法，对于不同的场景，可以按需选择。一个最佳实践是，<strong>确保自定义的runtime模块有良好的测试覆盖</strong>。</p>

<h3 id="rust-测试代码">Rust 测试代码</h3>

<p>Rust测试代码通常会和实现代码放在同一个文件或相同的目录下，取决于测试代码的数量，更多内容可以参考<a href="https://doc.rust-lang.org/book/ch11-03-test-organization.html">Rust book</a>。下面是一个简单的测试用例：</p>

<pre><code class="language-rust">pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add_two() {
        assert_eq!(4, add_two(2));
    }
}
</code></pre>

<p>一些需要注意的点包括：</p>

<ul>
<li>测试代码使用属性<code>#[cfg(test)]</code>进行标识</li>
<li><code>use super::*</code>用来引入当前模块的功能代码</li>
<li>测试函数通过属性<code>#[test]</code>进行标识</li>
<li>断言方式有：

<ul>
<li>表达式的值为true：<code>assert!(expression)</code></li>
<li>表达式的值是期望的值：<code>assert_eq!(expected, expression)</code></li>
<li>表达式的值不是其它不相关的值：<code>assert_ne!(other, expression)</code></li>
<li>异常发生：<code>#[should_panic]</code></li>
<li>Substrate提供了自定义的断言：</li>
<li>结果为<code>Ok(())</code>：<code>assert_ok!(expreesion)</code></li>
<li>结果为<code>Err(error_info)</code>：<code>assert_err!(expression, error_info)</code></li>
<li>结果为<code>Err(error_info)，并且不修改存储状态</code>：<code>assert_noop!(expression, error_info)</code></li>
</ul></li>
</ul>

<p><strong>运行测试</strong></p>

<pre><code class="language-shell">// 运行当前目录下的src目录和tests目录下的所有测试
cargo test

// 运行当前工作空间的所有package下的测试
cargo test --all

// 运行runtime路径下的所有测试，由cargo.toml的`[dependencies.demo-node-runtime]`标识
cargo test -p demo-node-runtime

// 运行runtime路径下单个模块的测试
cargo test -p demo-node-runtime mymodule

// 获取更多帮助信息
cargo test --help
</code></pre>

<p>运行结果大致如下：</p>

<pre><code>running 5 tests
test mymodule::tests::it_works_for_default_value ... ok
test mymodule::tests::play_should_work_for_lose ... ok
test mymodule::tests::set_payment_should_work ... ok
test mymodule::tests::play_should_work_for_win ... ok
test mymodule::tests::play_security_check_should_work ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out
</code></pre>

<h3 id="runtime-测试">Runtime 测试</h3>

<p>为了测试我们的runtime模块，需要首先引入相关的实现代码和依赖，</p>

<pre><code class="language-rust">use super::*;

use runtime_io::with_externalities;
use primitives::{H256, Blake2Hasher};
// --snip--
</code></pre>

<p>Runtime模块的功能被封装在一个结构体中，这里我们定义了一个mock的<code>Test</code> runtime结构体：</p>

<pre><code class="language-Rust">pub struct Test;
</code></pre>

<p><code>Test</code> runtime需要实现被测模块以及所依赖的runtime模块的配置接口，回忆一下我们的模块接口定义，自定义的模块接口继承balances的接口，而 <a href="https://github.com/paritytech/substrate/blob/master/srml/balances/src/lib.rs#L224">balances模块又继承了system的接口</a>：</p>

<pre><code class="language-rust">pub trait Trait: balances::Trait {
    type Event: From&lt;Event&lt;Self&gt;&gt; + Into&lt;&lt;Self as system::Trait&gt;::Event&gt;;
}
</code></pre>

<p>一些不关心的类型如<code>Event</code>可以用unit代替，这是因为Substrate为unit类型提供了多数接口的默认实现。这样，接口的实现分别是：</p>

<pre><code class="language-rust">impl system::Trait for Test {
    type Origin = Origin;
    // --snip--
}

impl balances::Trait for Test {
    type Balance = u64;
  	type OnFreeBalanceZero = ();
    // --snip--
}

impl Trait for Test {
    type Event = ();
}
</code></pre>

<p>我们还可以对用到的模块定义别名，方便后面的使用：</p>

<pre><code class="language-rust">type System = system::Module&lt;Test&gt;;
type Balances = balances::Module&lt;Test&gt;;
type mymodule = Module&lt;Test&gt;;
</code></pre>

<p>还记得runtime模块中callable function的第一个参数是<code>Origin</code>枚举类型吗？在实现代码中，<code>construct_runtime!</code>宏通过调用<code>impl_outer_origin!</code>自动为我们添加了<code>Origin</code>的定义。但是在测试代码中，我们需要自己调用<code>impl_outer_origin!</code>帮我们生成runtime所依赖的<code>Origin</code>类型，宏解析后的相关代码可以参考<a href="https://github.com/kaichaosun/substrate-real-estate-node/blob/master/runtime/expanded.rs#L4039">这里</a>：</p>

<pre><code class="language-rust">impl_outer_origin! {
		pub enum Origin for Test {}
}
</code></pre>

<h3 id="初始化genesisconfig">初始化GenesisConfig</h3>

<p>GenesisConfig存储了链上的原始状态，通常可以用来初始化：</p>

<ul>
<li>预置的账户</li>
<li>ROOT key</li>
<li>账户的余额等。</li>
</ul>

<p>这里首先初始化了system模块的GenesisConfig为所需的默认值，接着初始化balances模块，将Account ID为1的账户余额设置为10，Account ID为2的账户余额设置为20，其它的如交易费用等设置为0，方便我们计算测试结果。</p>

<pre><code class="language-rust">fn new_test_ext() -&gt; runtime_io::TestExternalities&lt;Blake2Hasher&gt; {
    let (mut t, mut c) = system::GenesisConfig::&lt;Test&gt;::default().build_storage().unwrap();

    let _ = balances::GenesisConfig::&lt;Test&gt;{
        balances: vec![
            (1, 10),
            (2, 20),
        ],
        transaction_base_fee: 0,
        transaction_byte_fee: 0,
        existential_deposit: 0,
        transfer_fee: 0,
        creation_fee: 0,
        vesting: vec![],
    }.assimilate_storage(&amp;mut t, &amp;mut c).unwrap();

    t.into()
}
</code></pre>

<h3 id="测试set-payment函数">测试set_payment函数</h3>

<p>我们通过属性<code>#[test]</code>标识了我们的测试函数为<code>set_payment_should_work</code>。当payment值为None时，设置payment为参数传入的值，当payment有值时，不做修改。</p>

<pre><code class="language-rust">#[test]
fn set_payment_should_work() {
    with_externalities(&amp;mut new_test_ext(), || {
        // Set payment when payment is none
        assert_ok!(mymodule::set_payment(Origin::signed(1), 100));
        assert_eq!(mymodule::payment(), Some(100));
        assert_eq!(mymodule::pot(), 100);

        // Set payment when payment is not none
        assert_ok!(mymodule::set_payment(Origin::signed(1), 200));
        assert_eq!(mymodule::payment(), Some(100));
        assert_eq!(mymodule::pot(), 100);
    });
}
</code></pre>

<h3 id="测试play函数">测试play函数</h3>

<p><strong>前置校验条件测试</strong>：</p>

<ul>
<li>函数调用应当是经过签名的</li>
<li>Payment中存储的值不应为空</li>
<li>当用户的余额小于Payment中的值时，应返回错误</li>

<li><p>当用户的余额多于Payment中的值是，应返回正常</p>

<pre><code class="language-rust">#[test]
fn play_security_check_should_work() {
with_externalities(&amp;mut new_test_ext(), || {
    // Test ensure_signed
    assert_noop!(mymodule::play(Origin::ROOT), &quot;bad origin: expected to be a signed origin&quot;);

    // Test payment must be set
    assert_noop!(mymodule::play(Origin::signed(2)), &quot;Must have payment amount set&quot;);

    // Check the balances in genesis config
    assert_eq!(Balances::total_balance(&amp;2), 20);

    // set payment and pot, higher than the balances
    &lt;Payment&lt;Test&gt;&gt;::put(30);
    &lt;Pot&lt;Test&gt;&gt;::put(30);

    assert_noop!(mymodule::play(Origin::signed(2)), &quot;too few free funds in account&quot;);

    // set payment and pot, lower than the balances
    &lt;Payment&lt;Test&gt;&gt;::put(10);
    &lt;Pot&lt;Test&gt;&gt;::put(10);
    assert_ok!(mymodule::play(Origin::signed(2)));
})
}
</code></pre></li>
</ul>

<p><strong>获胜情景测试</strong>：</p>

<ul>
<li>首先初始化所需的存储状态</li>
<li>设定随机种子</li>

<li><p>断言用户获胜后的数据状态</p>

<pre><code class="language-rust">#[test]
fn play_should_work_for_win() {
with_externalities(&amp;mut new_test_ext(), || {
    &lt;Payment&lt;Test&gt;&gt;::put(10);
    &lt;Pot&lt;Test&gt;&gt;::put(30);
    &lt;Nonce&lt;Test&gt;&gt;::put(1);
    System::set_random_seed(H256::from_low_u64_be(100));

    assert_ok!(mymodule::play(Origin::signed(2)));
    assert_eq!(mymodule::payment(), Some(10));
    assert_eq!(mymodule::pot(), 10);
    assert_eq!(Balances::total_balance(&amp;2), 40); // 20 - 10 (payment) + 30 (reward)
    assert_eq!(mymodule::nonce(), 2);
})
}
</code></pre></li>
</ul>

<p><strong>失败情景测试：</strong></p>

<p>和获胜情景类似，不过我们选用了不同的随机种子，从而使用户失败:</p>

<pre><code class="language-rust">#[test]
fn play_should_work_for_lose() {
    with_externalities(&amp;mut new_test_ext(), || {
        &lt;Payment&lt;Test&gt;&gt;::put(10);
        &lt;Pot&lt;Test&gt;&gt;::put(30);
        &lt;Nonce&lt;Test&gt;&gt;::put(1);
        System::set_random_seed(H256::from_low_u64_be(10));

        assert_ok!(mymodule::play(Origin::signed(2)));
        assert_eq!(mymodule::payment(), Some(10));
        assert_eq!(mymodule::pot(), 40);
        assert_eq!(Balances::total_balance(&amp;2), 10);
        assert_eq!(mymodule::nonce(), 2);
    })
}
</code></pre>

<p>完整的测试代码可参考<a href="https://github.com/kaichaosun/substrate-coin-flip/blob/master/runtime/src/mymodule.rs#L130-L280">这里</a>.</p>

<h2 id="ui开发">UI开发</h2>

<p><strong>用户体验差是限制区块链技术应用的一个重要方面</strong>，实用漂亮的UI可以显著的提升用户满意度。这里我们为开发的抛硬币游戏编写一个简单的前端页面。</p>

<p>这里我们使用的是Parity官方的前端应用模板 <a href="https://github.com/substrate-developer-hub/substrate-front-end-template">substrate-front-end-template</a>，基于</p>

<ul>
<li><p>React,</p></li>

<li><p>Semantic UI</p></li>

<li><p><a href="https://github.com/polkadot-js/api">polkadot/api</a></p></li>
</ul>

<h3 id="初始化api和状态">初始化API和状态</h3>

<p>根据项目的README文档可以快速启动这一模板应用，默认使用的是本地的节点WebSocket连接，即<code>ws://127.0.0.1:9944</code>，配置位于<a href="https://github.com/substrate-developer-hub/substrate-front-end-template/blob/master/src/config/development.json">development.json</a>。通过模板内置的<a href="https://github.com/substrate-developer-hub/substrate-front-end-template#usesubstrate-custom-hook">useSubstrate</a>功能函数来创建和Substrate节点交互的辅助组件，如api。</p>

<pre><code class="language-jsx">const { api } = useSubstrate();
</code></pre>

<p>新建一个自己的组件<code>CoinFlipGame.js</code>，初始化组件所需的state和设置对应state的函数，更多关于<code>userState</code>的解释参考 <a href="https://reactjs.org/docs/hooks-state.html">React官方文档</a>。</p>

<pre><code class="language-jsx">// The transaction submission status
const [status, setStatus] = useState(&quot;&quot;);
// The value stored in Payment
const [currentPayment, setCurrentPayment] = useState(0);
// The value stored in Pot
const [potReward, setPotReward] = useState(0);
// The value which will be set to Payment
const [formPayment, setFormPayment] = useState(0);
</code></pre>

<h3 id="状态更新">状态更新</h3>

<p>我们使用<a href="https://reactjs.org/docs/hooks-effect.html">useEffect</a>当<code>api.query.mymodule</code>的值发生变化时，重新设置currentPayment和potReward状态，当需要清理状态时调用相应的unsubscribe函数。</p>

<pre><code class="language-js">useEffect(() =&gt; {
  let paymentUnsubscribe;
  let potUnsubscribe;
  api.query.mymodule.payment(newPayment =&gt; {
    // The Payemnt storage value is an Option&lt;Balance&gt;
    // So we have to check whether it is None first
    // There is also unwrapOr
    if (newPayment.isNone) {
      setCurrentPayment('&lt;None&gt;');
    } else {
      setCurrentPayment(newPayment.unwrap().toNumber());
      setStorePaymentDisabled(true);
    }
  }).then(unsub =&gt; {
    paymentUnsubscribe = unsub;
  }).catch(console.error);

  api.query.mymodule.pot(reward =&gt; {
    setPotReward(reward.toNumber());
  }).then(unsub =&gt; {
    potUnsubscribe = unsub;
  }).catch(console.error);

  return () =&gt; paymentUnsubscribe &amp;&amp; potUnsubscribe &amp;&amp;
    paymentUnsubscribe() &amp;&amp; potUnsubscribe();
}, [api.query.mymodule]);
</code></pre>

<h3 id="ui组件">UI组件</h3>

<p>显示Payment和Pot的数据组件，如下：</p>

<pre><code class="language-jsx">&lt;Statistic
  label=&quot;Current Payment&quot;
  value={currentPayment}
/&gt;
    
&lt;Statistic
  label=&quot;Reward in Pot&quot;
  value={potReward}
/&gt;
</code></pre>

<p>我们还可以通过输入框设置Payment的初始值，通过Set Payment按钮发送请求到模块的set_payment可调用函数，一旦Payment的值被设置之后，该button的状态就会变成disable。现在，我们可以通过Play按钮玩游戏了，它会发送请求到runtime模块的play函数。这里用到的 <a href="https://github.com/substrate-developer-hub/substrate-front-end-template#txbutton-component">TxButton</a> 也是模板内置的一个组件，用来帮我们发送query或transaction请求，监控请求的状态。</p>

<pre><code class="language-jsx">&lt;Form&gt;
  &lt;Form.Field&gt;
    &lt;Input
      type=&quot;number&quot;
      id=&quot;new_payment&quot;
      label=&quot;New Payment&quot;
      onChange={(_, { value }) =&gt; setFormPayment(value)}
    /&gt;
  &lt;/Form.Field&gt;
  &lt;Form.Field&gt;
    &lt;TxButton
      accountPair={accountPair}
      label={'Set Payment'}
      disabled={storePaymentDisabled}
      setStatus={setStatus}
      type='TRANSACTION'
      attrs={{
        params: [formPayment],
        tx: api.tx.mymodule.setPayment
      }}
    /&gt;
    &lt;TxButton
      accountPair={accountPair}
      label={'Play Game'}
      setStatus={setStatus}
      type='TRANSACTION'
      attrs={{
        params: [],
        tx: api.tx.mymodule.play
      }}
    /&gt;
  &lt;/Form.Field&gt;
  &lt;div style={{ overflowWrap: 'break-word' }}&gt;{status}&lt;/div&gt;
&lt;/Form
</code></pre>

<p>可调用函数play执行完成后，在Events结果中，可以看到我们定义的<code>mymodule:PlayResult</code>事件，及用户的地址和赢得的奖励，测试结果如下图所示。</p>

<p><img src="https://i.imgur.com/GaXEuDy.png" alt="coin_flip_play" /></p>

<h2 id="总结">总结</h2>

<p>恭喜你，到这里你已经掌握了基于Substrate开发应用链的基本知识：</p>

<ul>
<li>实现runtime逻辑</li>
<li>编写测试</li>
<li>前端页面</li>
</ul>

<p>如果你想学习更多前端开发的知识，请参考<a href="https://substrate.dev/docs/en/tutorials/substrate-front-end/">Substrate Front-End Tutorial</a>，还可以通过不同的练习如<a href="https://github.com/substrate-developer-hub/substrate-collectables-workshop">substrate-collectables-workshop</a>，甚至编写自己的业务runtime，来巩固这些知识并熟练应用。</p>

<p><a href="https://substrate.dev/">Substrate开发者中心</a>提供了很多学习资料，时常去逛一下，会有不同的收获。</p>

    </section>
</article>

<footer id="post-meta" class="clearfix">
    <a href="https://twitter.com/SunWillsuna">
    <img class="avatar" src="https://whisperd.tech/images/avatar.png">
    <div>
        <span class="dark">Kaichao Sun</span>
        <span>Mark it down</span>
    </div>
    </a>
    <section id="sharing">
        <a class="twitter" href="https://twitter.com/intent/tweet?text=https%3a%2f%2fwhisperd.tech%2fpost%2fcoin_flip_test_and_ui%2f - %e6%8a%9b%e7%a1%ac%e5%b8%81%e6%b8%b8%e6%88%8f%28%e4%ba%8c%29%ef%bc%9a%e7%bc%96%e5%86%99%e6%b5%8b%e8%af%95%e5%92%8cUI by @SunWillsuna"><span class="icon-twitter"> tweet</span></a>

<a class="facebook" href="#" onclick="
    window.open(
      'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
      'facebook-share-dialog',
      'width=626,height=436');
    return false;"><span class="icon-facebook-rect"> Share</span>
</a>

    </section>
</footer>

<div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "whisperd" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

<ul id="post-list" class="archive readmore">
    <h3>Read more</h3>

    
    
    
        <li>
            <a href="/post/substrate_coin_flip/">Substrate应用 - 抛硬币游戏(一)<aside class="dates">Aug 5 2019</aside></a>
        </li>
    
        <li>
            <a href="/post/substrate_blockchain_setup/">使用Substrate搭建你的第一条区块链<aside class="dates">May 28 2019</aside></a>
        </li>
    
        <li>
            <a href="/post/why_oo_sucks/">Why OO Sucks<aside class="dates">Apr 25 2019</aside></a>
        </li>
    
        <li>
            <a href="/post/solidity-basics/">理解Ethereum智能合约开发<aside class="dates">Apr 11 2019</aside></a>
        </li>
    
        <li>
            <a href="/post/shell-cheatsheet/">Cheatsheet for Shell Programming<aside class="dates">Mar 30 2019</aside></a>
        </li>
    
        <li>
            <a href="/post/master_linux_os/">The Tutorial of Manjaro Linux Usage<aside class="dates">Mar 3 2019</aside></a>
        </li>
    
        <li>
            <a href="/post/laozhai-jiyi/">老宅记忆<aside class="dates">Feb 6 2019</aside></a>
        </li>
    
        <li>
            <a href="/post/dependency_injection_in_scala/">Dependency Injection in Scala<aside class="dates">Jan 17 2019</aside></a>
        </li>
    
        <li>
            <a href="/post/error_handling_in_scala/">Understand Error Handling in Scala<aside class="dates">Jan 17 2019</aside></a>
        </li>
    
        <li>
            <a href="/post/common-cli-cheatsheet/">Cheatsheet for Common Usage CLI<aside class="dates">Jan 2 2019</aside></a>
        </li>
    
</ul>



        
<footer id="footer">
    
        <div id="social">

	
	
    <a class="symbol" href="https://github.com/kaichaosun">
        <i class="fa fa-github"></i>
    </a>
    
    <a class="symbol" href="https://twitter.com/kaichaosun">
        <i class="fa fa-twitter"></i>
    </a>
    


</div>

    
    <p class="small">
    
        © Copyright 2019 Kaichao Sun
    
    </p>
</footer>

    </section>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script src="https://whisperd.tech/js/main.js"></script>
<script src="https://whisperd.tech/js/highlight.js"></script>
<script src="https://whisperd.tech/js/fix-toc.js"></script>

<script>hljs.initHighlightingOnLoad();</script>



  
    
    
  







<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-128168145-1', 'auto');
	
	ga('send', 'pageview');
}
</script>


</body>
</html>
