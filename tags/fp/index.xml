<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>FP on Whisperd</title><link>https://kaichaosun.github.io/tags/fp/</link><description>Recent content in FP on Whisperd</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 25 Apr 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://kaichaosun.github.io/tags/fp/index.xml" rel="self" type="application/rss+xml"/><item><title>Why OO Sucks</title><link>https://kaichaosun.github.io/post/why_oo_sucks/</link><pubDate>Thu, 25 Apr 2019 00:00:00 +0000</pubDate><guid>https://kaichaosun.github.io/post/why_oo_sucks/</guid><description>原文为英文，由 Joe Armstrong 撰写。我的翻译如下。
当我第一次接触OOP(Object Oriented Programming, 面向对象编程)概念的时候，就感到十分怀疑，但是又不知道为什么，就是感觉&amp;quot;不对&amp;rdquo;。当OOP变得非常流行(下面会解释原因)，批判OOP就像&amp;rdquo;在教堂诅咒&amp;ldquo;一样会被排斥。OO逐渐成为了主流编程语言必须要有的特性。
随着Erlang变得流行，我们经常被问到&amp;quot;Erlang是面向对象的吗？&amp;quot;。真正的答案当然是&amp;quot;不支持&amp;rdquo;，但是我们并不敢对外这么说，为此我们发明了一系列巧妙的方式来回答这个问题，给大家营造一种Erlang在某种程度上是OO，但又不真的是OO(如果仔细听我们说的，看小字印刷的内容就知道了)。
这个时候，我想到了 IBM 那时的老板在巴黎第七届IEEE Logic 编程会议时, 被问及IBM Prolog为什么添加了一系列面向对象的扩展，回答是：
我们的客户希望使用面向对象的Prolog，所以我们就创造了面向对象的Prolog。
我当时的想法是&amp;quot;这么简单粗暴的回答，没有任何良心上的不安，没有灵魂深处的拷问，也没有想过这是不是正确的事情 …&amp;hellip;&amp;rdquo;
面向对象为什么糟糕 对面向对象的主要反对理由可以回归到面向对象的基本理念，在这里我会简述其中一些基本理念以及我对它们的反对意见。
反对1. 数据结构和函数不应该捆绑在一起 对象将数据和函数绑定在了一个不可分割的单元。我认为这是一个根本性的错误，因为函数和数据属于完全不同的两个世界。为什么这么说呢？
函数的作用是处理一些事情。它们有输入和输出。输入和输出是数据，数据可以被函数所改变。在大多数编程语言里，函数由一系列指令所构建：&amp;ldquo;先干这个，之后再干那个……&amp;quot;。为了理解函数，你必须理解这些事情以何种顺序完成。(在支持延迟计算的函数式编程语言中，这个限制并不严格。) 而数据就静静的待在那里。它们什么都不做。它们本身是声明性的。&amp;ldquo;理解&amp;quot;数据远比&amp;quot;理解&amp;quot;函数简单的多。 为了便于理解，函数通常被当作&amp;quot;黑盒&amp;quot;处理，用来把输入转换成输出。如果我理解了输入和输出，那么我就理解了这个函数。但这不意味着我可以写出这个函数。
通常可以认为函数是计算系统的一些&amp;quot;部件&amp;rdquo;，它们的职责是从一种数据结构转换成另一种数据结构。
函数和数据是完全不同的两类&amp;quot;动物&amp;rdquo;，强行把它们锁在同一个&amp;quot;笼子&amp;quot;里，本身就是不正确的。
反对2. 一切事物都必须是一个对象 想想**&amp;ldquo;时间&amp;rdquo;**，在面向对象编程语言中，&amp;ldquo;时间&amp;quot;必须是一个对象。(在Smalltalk中，甚至&amp;quot;3&amp;quot;都是一个对象)。但是在非面向对象的语言中，&amp;ldquo;时间&amp;quot;只是某种数据类型的实例。例如，在Erlang中，存在各种各样的时间表示形式，通过使用类型声明可以清晰明确地进行指定，如：
-deftype day() = 1..31. -deftype month() = 1..12. -deftype year() = int(). -deftype hour() = 1..24. -deftype minute() = 1..60. -deftype second() = 1..60. -deftype abstime() = {abstime,year(),month(),day(),hour(),min(),sec()}. -deftype hms() = {hms,hour(),min(),sec()}. … 注意：上面的定义不属于任意特定的对象。它们是通用的，系统中的任意的函数（译者：这里的函数并不指代已有签名的那些函数，而是对函数的概指）都可以处理以上数据结构所表示的时间。</description></item><item><title>Dependency Injection in Scala</title><link>https://kaichaosun.github.io/post/dependency_injection_in_scala/</link><pubDate>Thu, 17 Jan 2019 00:00:00 +0000</pubDate><guid>https://kaichaosun.github.io/post/dependency_injection_in_scala/</guid><description>What's Dependency Injection Dependency Injection is also known as DI for short. It is all about the way to integrate code between provider and consumer.
Usually, the provider provides functionalities that encapsulated in a function or an object. The consumer, in the opposite it needs to have a provider to do some work.
Then we say that the consumer dependent on the specific provider. There are two options that we can get this provider:</description></item><item><title>Understand Error Handling in Scala</title><link>https://kaichaosun.github.io/post/error_handling_in_scala/</link><pubDate>Thu, 17 Jan 2019 00:00:00 +0000</pubDate><guid>https://kaichaosun.github.io/post/error_handling_in_scala/</guid><description>What's Exception Exception are objects that defined in Java to represent error scenarios. Unhandled exceptions could terminate the program or show default message from http server.
Excpetion hirarchy Since Scala is designed to reuse Java standard or thirdparth library without much effort. It still worth to know the exception hirarachy originated in Java. It will help us deal with error scenarios.
Throwable is the root of exception hirarchy. Exception subclasses represent errors that the program can recover from.</description></item><item><title>Understand Monad in Functional Programming</title><link>https://kaichaosun.github.io/post/understand-monad/</link><pubDate>Sat, 13 Oct 2018 00:00:00 +0000</pubDate><guid>https://kaichaosun.github.io/post/understand-monad/</guid><description>Why Functional Programming? The facination of doing programming is to solve the exist problems. Revisit the history of software development, at first place we have procedure-oriented programming. As the system becomes bigger, the codebase is so hard to maintain and adding new features. Then a few genius comes out the idea with OOP with the SOLID principles to guide the daily dev work.
If there is one rule in software development, i think that must be no silver bullet.</description></item></channel></rss>